use super::data::MacroData;
use all_syntax_cases_helpers::{matched_check, matched_check_no_fields, struct_check};
use proc_macro2::Span;
use quote::{ToTokens, quote};
use syn::{
    Abi, AngleBracketedGenericArguments, Arm, Attribute, BareFnArg, BareVariadic, BinOp, Block,
    BoundLifetimes, CapturedParam, Expr, Field, FieldMutability, FieldPat, FieldValue, Fields,
    FieldsNamed, FnArg, ForeignItem, GenericArgument, GenericParam, Generics, Ident, ImplItem,
    ImplRestriction, Item, Label, Lifetime, Lit, LocalInit, Macro, Member, Pat, PatRest, Path,
    PointerMutability, QSelf, RangeLimits, ReturnType, Signature, StaticMutability, Token,
    TraitBoundModifier, TraitItem, Type, TypeParamBound, UnOp, UseTree, Variadic, Variant,
    Visibility, WhereClause, WherePredicate,
    punctuated::Punctuated,
    token::{Brace, Bracket, Group, Paren},
};
// Item
pub fn item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.item;

    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Item::Const(syn::ItemConst {
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub const_token: Token![const],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
        }));

        matched_check!(syn::Item::Enum(syn::ItemEnum{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub enum_token: Token![enum],
            pub ident: Ident,
            pub generics: Generics,
            pub brace_token: syn::token::Brace,
            pub variants: Punctuated<Variant, Token![,]>,
        }));
        matched_check!(syn::Item::ExternCrate(syn::ItemExternCrate{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub extern_token: Token![extern],
            pub crate_token: Token![crate],
            pub ident: Ident,
            pub rename: Option<(Token![as], Ident)>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Fn(syn::ItemFn{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub sig: Signature,
            pub block: Box<Block>,
        }));
        matched_check!(syn::Item::ForeignMod(syn::ItemForeignMod{
            pub attrs: Vec<Attribute>,
            pub unsafety: Option<Token![unsafe]>,
            pub abi: Abi,
            pub brace_token: syn::token::Brace,
            pub items: Vec<ForeignItem>,
        }));
        matched_check!(syn::Item::Impl(syn::ItemImpl{
            pub attrs: Vec<Attribute>,
            pub defaultness: Option<Token![default]>,
            pub unsafety: Option<Token![unsafe]>,
            pub impl_token: Token![impl],
            pub generics: Generics,
            pub trait_: Option<(Option<Token![!]>, Path, Token![for])>,
            pub self_ty: Box<Type>,
            pub brace_token: syn::token::Brace,
            pub items: Vec<ImplItem>,
        }));
        matched_check!(syn::Item::Macro(syn::ItemMacro{
            pub attrs: Vec<Attribute>,
            /// The `example` in `macro_rules! example { ... }`.
            pub ident: Option<Ident>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Mod(syn::ItemMod{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub unsafety: Option<Token![unsafe]>,
            pub mod_token: Token![mod],
            pub ident: Ident,
            pub content: Option<(syn::token::Brace, Vec<Item>)>,
            pub semi: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Static(syn::ItemStatic{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub static_token: Token![static],
            pub mutability: StaticMutability,
            pub ident: Ident,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Struct(syn::ItemStruct{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub struct_token: Token![struct],
            pub ident: Ident,
            pub generics: Generics,
            pub fields: Fields,
            pub semi_token: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Trait(syn::ItemTrait{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub unsafety: Option<Token![unsafe]>,
            pub auto_token: Option<Token![auto]>,
            pub restriction: Option<ImplRestriction>,
            pub trait_token: Token![trait],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Option<Token![:]>,
            pub supertraits: Punctuated<TypeParamBound, Token![+]>,
            pub brace_token: syn::token::Brace,
            pub items: Vec<TraitItem>,
        }));
        matched_check!(syn::Item::TraitAlias(syn::ItemTraitAlias{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub trait_token: Token![trait],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Type(syn::ItemType{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub ty: Box<Type>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Union(syn::ItemUnion{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub union_token: Token![union],
            pub ident: Ident,
            pub generics: Generics,
            pub fields: FieldsNamed,
        }));
        matched_check!(syn::Item::Use(syn::ItemUse{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub use_token: Token![use],
            pub leading_colon: Option<Token![::]>,
            pub tree: UseTree,
            pub semi_token: Token![;],
        }));
    }

    result_matches.extend(quote! {
        syn::Item::Verbatim(token_stream) => {
            todo!("syn::Item::Verbatim is unsupported by all_syntax_cases macro")
        }
        i => todo!(
            "Item not supported yet by all_syntax_cases macro | Item: {}",
            i.to_token_stream()
        ),
    });

    quote! {
        fn #fn_name(
            item: &mut syn::Item,
            #additional_input_name: #additional_input_ty,
        ) {
            match item {
                #result_matches
            }
        }
    }
}
// Expr
pub fn expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.expr;

    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Expr::Array(syn::ExprArray {
            pub attrs: Vec<Attribute>,
            pub bracket_token: syn::token::Bracket,
            pub elems: Punctuated<Expr, Token![,]>,
        }));
        matched_check!(syn::Expr::Assign(syn::ExprAssign {
            pub attrs: Vec<Attribute>,
            pub left: Box<Expr>,
            pub eq_token: Token![=],
            pub right: Box<Expr>,

        }));
        matched_check!(syn::Expr::Async(syn::ExprAsync {
            pub attrs: Vec<Attribute>,
            pub async_token: Token![async],
            pub capture: Option<Token![move]>,
            pub block: Block,
        }));
        matched_check!(syn::Expr::Await(syn::ExprAwait {
            pub attrs: Vec<Attribute>,
            pub base: Box<Expr>,
            pub dot_token: Token![.],
            pub await_token: Token![await],
        }));
        matched_check!(syn::Expr::Binary(syn::ExprBinary {
            pub attrs: Vec<Attribute>,
            pub left: Box<Expr>,
            pub op: BinOp,
            pub right: Box<Expr>,

        }));
        matched_check!(syn::Expr::Block(syn::ExprBlock {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub block: Block,

        }));
        matched_check!(syn::Expr::Break(syn::ExprBreak {
            pub attrs: Vec<Attribute>,
            pub break_token: Token![break],
            pub label: Option<Lifetime>,
            pub expr: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Call(syn::ExprCall {
            pub attrs: Vec<Attribute>,
            pub func: Box<Expr>,
            pub paren_token: Paren,
            pub args: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Cast(syn::ExprCast {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub as_token: Token![as],
            pub ty: Box<Type>,

        }));
        matched_check!(syn::Expr::Closure(syn::ExprClosure {
            pub attrs: Vec<Attribute>,
            pub lifetimes: Option<BoundLifetimes>,
            pub constness: Option<Token![const]>,
            pub movability: Option<Token![static]>,
            pub asyncness: Option<Token![async]>,
            pub capture: Option<Token![move]>,
            pub or1_token: Token![|],
            pub inputs: Punctuated<Pat, Token![,]>,
            pub or2_token: Token![|],
            pub output: ReturnType,
            pub body: Box<Expr>,

        }));
        matched_check!(syn::Expr::Const(syn::ExprConst {
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub block: Block,

        }));
        matched_check!(syn::Expr::Continue(syn::ExprContinue {
            pub attrs: Vec<Attribute>,
            pub continue_token: Token![continue],
            pub label: Option<Lifetime>,

        }));
        matched_check!(syn::Expr::Field(syn::ExprField {
            pub attrs: Vec<Attribute>,
            pub base: Box<Expr>,
            pub dot_token: Token![.],
            pub member: Member,

        }));
        matched_check!(syn::Expr::ForLoop(syn::ExprForLoop {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub for_token: Token![for],
            pub pat: Box<Pat>,
            pub in_token: Token![in],
            pub expr: Box<Expr>,
            pub body: Block,

        }));
        matched_check!(syn::Expr::Group(syn::ExprGroup {
            pub attrs: Vec<Attribute>,
            pub group_token: Group,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::If(syn::ExprIf {
            pub attrs: Vec<Attribute>,
            pub if_token: Token![if],
            pub cond: Box<Expr>,
            pub then_branch: Block,
            pub else_branch: Option<(Token![else], Box<Expr>)>,

        }));
        matched_check!(syn::Expr::Index(syn::ExprIndex {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub bracket_token: syn::token::Bracket,
            pub index: Box<Expr>,

        }));
        matched_check!(syn::Expr::Infer(syn::ExprInfer {
            pub attrs: Vec<Attribute>,
            pub underscore_token: Token![_],

        }));
        matched_check!(syn::Expr::Let(syn::ExprLet {
            pub attrs: Vec<Attribute>,
            pub let_token: Token![let],
            pub pat: Box<Pat>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Lit(syn::ExprLit {
            pub attrs: Vec<Attribute>,
            pub lit: Lit,

        }));
        matched_check!(syn::Expr::Loop(syn::ExprLoop {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub loop_token: Token![loop],
            pub body: Block,

        }));
        matched_check!(syn::Expr::Macro(syn::ExprMacro {
            pub attrs: Vec<Attribute>,
            pub mac: Macro,

        }));
        matched_check!(syn::Expr::Match(syn::ExprMatch {
            pub attrs: Vec<Attribute>,
            pub match_token: Token![match],
            pub expr: Box<Expr>,
            pub brace_token: syn::token::Brace,
            pub arms: Vec<Arm>,

        }));
        matched_check!(syn::Expr::MethodCall(syn::ExprMethodCall {
            pub attrs: Vec<Attribute>,
            pub receiver: Box<Expr>,
            pub dot_token: Token![.],
            pub method: Ident,
            pub turbofish: Option<AngleBracketedGenericArguments>,
            pub paren_token: Paren,
            pub args: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Paren(syn::ExprParen {
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Path(syn::ExprPath {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,

        }));
        matched_check!(syn::Expr::Range(syn::ExprRange {
            pub attrs: Vec<Attribute>,
            pub start: Option<Box<Expr>>,
            pub limits: RangeLimits,
            pub end: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::RawAddr(syn::ExprRawAddr {
            pub attrs: Vec<Attribute>,
            pub and_token: Token![&],
            pub raw: Token![raw],
            pub mutability: PointerMutability,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Reference(syn::ExprReference {
            pub attrs: Vec<Attribute>,
            pub and_token: Token![&],
            pub mutability: Option<Token![mut]>,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Repeat(syn::ExprRepeat {
            pub attrs: Vec<Attribute>,
            pub bracket_token: syn::token::Bracket,
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
            pub len: Box<Expr>,

        }));
        matched_check!(syn::Expr::Return(syn::ExprReturn {
            pub attrs: Vec<Attribute>,
            pub return_token: Token![return],
            pub expr: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Struct(syn::ExprStruct {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,
            pub brace_token: syn::token::Brace,
            pub fields: Punctuated<FieldValue, Token![,]>,
            pub dot2_token: Option<Token![..]>,
            pub rest: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Try(syn::ExprTry {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub question_token: Token![?],

        }));
        matched_check!(syn::Expr::TryBlock(syn::ExprTryBlock {
            pub attrs: Vec<Attribute>,
            pub try_token: Token![try],
            pub block: Block,

        }));
        matched_check!(syn::Expr::Tuple(syn::ExprTuple {
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub elems: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Unary(syn::ExprUnary {
            pub attrs: Vec<Attribute>,
            pub op: UnOp,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Unsafe(syn::ExprUnsafe {
            pub attrs: Vec<Attribute>,
            pub unsafe_token: Token![unsafe],
            pub block: Block,

        }));
        matched_check!(syn::Expr::While(syn::ExprWhile {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub while_token: Token![while],
            pub cond: Box<Expr>,
            pub body: Block,

        }));
        matched_check!(syn::Expr::Yield(syn::ExprYield {
            pub attrs: Vec<Attribute>,
            pub yield_token: Token![yield],
            pub expr: Option<Box<Expr>>,
        }));
    }

    result_matches.extend(quote! {
        syn::Expr::Verbatim(token_stream) => {
            todo!("syn::Expr::Verbatim is unsupported by all_syntax_cases macro")
        }
        i => todo!(
            "Expr not supported yet by all_syntax_cases macro | Expr: {}",
            i.to_token_stream()
        ),
    });

    quote! {
        fn #fn_name(
            expr: &mut syn::Expr,
            #additional_input_name: #additional_input_ty,
        ) {
            match expr {
                #result_matches
            }
        }
    }
}
// Option<Expr>
pub fn option_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.expr_option;
    let fn_name_expr = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            expr: &mut Option<syn::Expr>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(ex) = expr{
                //No need to clone additional since we don't use additional_input multiple times
                #fn_name_expr(ex, #additional_input_name);
            }
        }
    }
}
// Block
pub fn block_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.block;

    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Block{
        pub brace_token: syn::token::Brace,
        /// Statements in a block
        pub stmts: Vec<syn::Stmt>,
    });

    quote! {
        fn #fn_name(
            block: &mut syn::Block,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// Stmt
pub fn stmt_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.stmt;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Stmt::Local(syn::Local{
            pub attrs: Vec<Attribute>,
            pub let_token: Token![let],
            pub pat: Pat,
            pub init: Option<LocalInit>,
            pub semi_token: Token![;],
        }));
        matched_check_no_fields!(syn::Stmt::Item(syn::Item));
        matched_check_no_fields!(syn::Stmt::Expr(syn::Expr, Option<Token![;]>));
        matched_check!(syn::Stmt::Macro(syn::StmtMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    quote! {
        fn #fn_name(
            stmt: &mut syn::Stmt,
            #additional_input_name: #additional_input_ty,
        ) {
            match stmt {
                #result_matches
            }
        }
    }
}
// BoundLifetimes
pub fn bound_lifetimes_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.bound_lifetimes;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::BoundLifetimes{
        pub for_token: Token![for],
        pub lt_token: Token![<],
        pub lifetimes: Punctuated<GenericParam, Token![,]>,
        pub gt_token: Token![>],
    });

    quote! {
        fn #fn_name(
            bound_lifetimes: &mut syn::BoundLifetimes,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// Option<BoundLifetimes>
pub fn option_bound_lifetimes_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.bound_lifetimes_option;
    let bound_lifetimes_fn_name = &fn_names.bound_lifetimes;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            bound_lifetimes: &mut Option<syn::BoundLifetimes>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(bl) = bound_lifetimes{
                //No need to clone additional since we don't use additional_input multiple times
                #bound_lifetimes_fn_name(bl, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.bound_lifetimes);

    final_result
}
// TypeParamBound
pub fn type_param_bound_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.type_param_bound;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::TypeParamBound::Trait(syn::TraitBound{
            pub paren_token: Option<Paren>,
            pub modifier: TraitBoundModifier,
            pub lifetimes: Option<BoundLifetimes>,
            pub path: Path,
        }));

        matched_check!(syn::TypeParamBound::Lifetime(syn::Lifetime{
            pub apostrophe: Span,
            pub ident: Ident,
        }));

        matched_check!(syn::TypeParamBound::PreciseCapture(syn::PreciseCapture{
            pub use_token: Token![use],
            pub lt_token: Token![<],
            pub params: Punctuated<CapturedParam, Token![,]>,
            pub gt_token: Token![>],
        }));
    }

    result_matches.extend(quote! {
        syn::TypeParamBound::Verbatim(_) => {
            todo!("syn::TypeParamBound::Verbatim not supported by all_syntax_cases macro")
        },
        i => {
            todo!("syn::TypeParamBound not supported yet by all_syntax_cases macro | TypeParamBound: {}", i.to_token_stream())
        },
    });

    quote! {
        fn #fn_name(
            type_param_bound: &mut syn::TypeParamBound,
            #additional_input_name: #additional_input_ty,
        ) {
            match type_param_bound {
                #result_matches
            }
        }
    }
}
// GenericParam
pub fn generic_param_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.stmt;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::GenericParam::Type(syn::TypeParam{
            pub attrs: Vec<Attribute>,
            pub ident: Ident,
            pub colon_token: Option<Token![:]>,
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
            pub eq_token: Option<Token![=]>,
            pub default: Option<Type>,
        }));

        matched_check!(syn::GenericParam::Lifetime(syn::LifetimeParam{
            pub attrs: Vec<Attribute>,
            pub lifetime: Lifetime,
            pub colon_token: Option<Token![:]>,
            pub bounds: Punctuated<Lifetime, Token![+]>,
        }));

        matched_check!(syn::GenericParam::Const(syn::ConstParam{
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub ident: Ident,
            pub colon_token: Token![:],
            pub ty: Type,
            pub eq_token: Option<Token![=]>,
            pub default: Option<Expr>,
        }));
    }

    quote! {
        fn #fn_name(
            generic_param: &mut syn::GenericParam,
            #additional_input_name: #additional_input_ty,
        ) {
            match generic_param {
                #result_matches
            }
        }
    }
}
// WherePredicate
pub fn where_predicate_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.where_predicate;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::WherePredicate::Lifetime(syn::PredicateLifetime{
            pub lifetime: Lifetime,
            pub colon_token: Token![:],
            pub bounds: Punctuated<Lifetime, Token![+]>,
        }));

        matched_check!(syn::WherePredicate::Type(syn::PredicateType{
            /// Any lifetimes from a `for` binding
            pub lifetimes: Option<BoundLifetimes>,
            /// The type being bounded
            pub bounded_ty: Type,
            pub colon_token: Token![:],
            /// Trait and lifetime bounds (`Clone+Send+'static`)
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
        }));
    }

    quote! {
        fn #fn_name(
            where_predicate: &mut syn::WherePredicate,
            #additional_input_name: #additional_input_ty,
        ) {
            match where_predicate {
                #result_matches
                i=>{
                    panic!("syn::WherePredicate not supported yet by all_syntax_cases macro | WherePredicate: {}", i.to_token_stream())
                }
            }
        }
    }
}

// WhereClause
pub fn where_clause_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.where_clause;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::WhereClause{
        pub where_token: Token![where],
        pub predicates: Punctuated<WherePredicate, Token![,]>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::WhereClause,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<WhereClause>
pub fn option_where_clause_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.where_clause_option;
    let where_clause_fn_name = &fn_names.where_clause;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            where_clause: &mut Option<syn::WhereClause>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(wc) = where_clause{
                //No need to clone additional since we don't use additional_input multiple times
                #where_clause_fn_name(wc, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.where_clause);

    final_result
}

// Generics
pub fn generics_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.generics;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Generics{
        pub lt_token: Option<Token![<]>,
        pub params: Punctuated<GenericParam, Token![,]>,
        pub gt_token: Option<Token![>]>,
        pub where_clause: Option<WhereClause>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Generics,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// ImplItem
pub fn impl_item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.impl_item;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::ImplItem::Const(syn::ImplItemConst{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub const_token: Token![const],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Token![:],
            pub ty: Type,
            pub eq_token: Token![=],
            pub expr: Expr,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ImplItem::Fn(syn::ImplItemFn{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub sig: Signature,
            pub block: Block,
        }));
        matched_check!(syn::ImplItem::Type(syn::ImplItemType{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub ty: Type,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ImplItem::Macro(syn::ImplItemMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    result_matches.extend(quote! {
        syn::ImplItem::Verbatim(token_stream) => {
            todo!("syn::ImplItem::Verbatim is unsupported by all_syntax_cases macro")
        }
        i=>{
            todo!("syn::ImplItem not supported yet by all_syntax_cases macro | ImplItem: {}", i.to_token_stream())
        }
    });

    quote! {
        fn #fn_name(
            impl_item: &mut syn::ImplItem,
            #additional_input_name: #additional_input_ty,
        ) {
            match impl_item {
                #result_matches
            }
        }
    }
}
// Signature
pub fn signature_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.signature;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Signature{
        pub constness: Option<Token![const]>,
        pub asyncness: Option<Token![async]>,
        pub unsafety: Option<Token![unsafe]>,
        pub abi: Option<Abi>,
        pub fn_token: Token![fn],
        pub ident: Ident,
        pub generics: Generics,
        pub paren_token: Paren,
        pub inputs: Punctuated<FnArg, Token![,]>,
        pub variadic: Option<Variadic>,
        pub output: ReturnType,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Signature,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// FnArg
pub fn fn_arg_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fn_arg;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    // Matches generated by matched_check!
    {
        matched_check!(syn::FnArg::Receiver(syn::Receiver{
            pub attrs: Vec<Attribute>,
            pub reference: Option<(Token![&], Option<Lifetime>)>,
            pub mutability: Option<Token![mut]>,
            pub self_token: Token![self],
            pub colon_token: Option<Token![:]>,
            pub ty: Box<Type>,
        }));
        matched_check!(syn::FnArg::Typed(syn::PatType{
            pub attrs: Vec<Attribute>,
            pub pat: Box<Pat>,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
        }));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::FnArg,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
            }
        }
    }
}
// variadic_pat: Option<(Box<Pat>, Token![:])>,
pub fn variadic_pat_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.variadic_pat;
    let pat_fn_name = &fn_names.pat;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(Box<syn::Pat>, Token![:])>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                #pat_fn_name(&mut search_item.0, #additional_input_name);
            }
        }
    }
}
// Variadic
pub fn variadic_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.variadic;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Variadic{
        pub attrs: Vec<Attribute>,
        pub pat: Option<(Box<Pat>, Token![:])>,
        pub dots: Token![...],
        pub comma: Option<Token![,]>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Variadic,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// Option<Variadic>
pub fn option_variadic_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.variadic_option;
    let variadic_fn_name = &fn_names.variadic;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            search_item: &mut Option<syn::Variadic>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                #variadic_fn_name(search_item, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.variadic);

    final_result
}
// item_mod_content: Option<(syn::token::Brace, Vec<Item>)>,
pub fn item_mod_content_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.item_mod_content;
    let item_fn_name = &fn_names.item;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(syn::token::Brace, Vec<Item>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, items)) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                for item in items.iter_mut(){
                    #item_fn_name(item, #additional_input_name.clone());
                }
            }
        }
    }
}
// Fields
pub fn fields_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fields;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Fields::Named(syn::FieldsNamed{
            pub brace_token: Brace,
            pub named: Punctuated<Field, Token![,]>,
        }));

        matched_check!(syn::Fields::Unnamed(syn::FieldsUnnamed{
            pub paren_token: Paren,
            pub unnamed: Punctuated<Field, Token![,]>,
        }));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::Fields,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                syn::Fields::Unit => {
                    //It's kinda hard to handle no data, y'know
                },
                #result_matches
            }
        }
    }
}
// Field
pub fn field_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.field;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Field{
        pub attrs: Vec<Attribute>,

        pub vis: Visibility,

        pub mutability: FieldMutability,

        /// Name of the field, if any.
        ///
        /// Fields of tuple structs have no names.
        pub ident: Option<Ident>,

        pub colon_token: Option<Token![:]>,

        pub ty: Type,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Field,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// TraitItem
pub fn trait_item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.trait_item;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::TraitItem::Const(syn::TraitItemConst{
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Token![:],
            pub ty: Type,
            pub default: Option<(Token![=], Expr)>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::TraitItem::Fn(syn::TraitItemFn{
            pub attrs: Vec<Attribute>,
            pub sig: Signature,
            pub default: Option<Block>,
            pub semi_token: Option<Token![;]>,
        }));
        matched_check!(syn::TraitItem::Type(syn::TraitItemType{
            pub attrs: Vec<Attribute>,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Option<Token![:]>,
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
            pub default: Option<(Token![=], Type)>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::TraitItem::Macro(syn::TraitItemMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    result_matches.extend(quote! {
        syn::TraitItem::Verbatim(_) => {
            todo!("syn::TraitItem::Verbatim is unsupported by all_syntax_cases macro")
        }
        i=>{
            todo!("syn::TraitItem not supported yet by all_syntax_cases macro | TraitItem: {}", i.to_token_stream())
        }
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::TraitItem,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
            }
        }
    }
}

// Option<Block>
pub fn option_block_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_block;
    let block_fn_name = &fn_names.block;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_block: &mut Option<syn::Block>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(block) = option_block{
                //No need to clone additional since we don't use additional_input multiple times
                #block_fn_name(block, #additional_input_name);
            }
        }
    }
}

// Option<(Token![=], Expr)>
pub fn option_eq_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_eq_expr;
    let eq_expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_eq_expr: &mut Option<(Token![=], Box<syn::Expr>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, box_expr)) = option_eq_expr{
                //No need to clone additional since we don't use additional_input multiple times
                #eq_expr_fn_name(box_expr, #additional_input_name);
            }
        }
    }
}

// FieldsNamed
pub fn fields_named_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fields_named;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();
    struct_check!(syn::FieldsNamed{
        pub brace_token: Brace,
        pub named: Punctuated<Field, Token![,]>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::FieldsNamed,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<Box<Expr>>
pub fn option_box_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_box_expr;
    let box_expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_box_expr: &mut Option<Box<syn::Expr>>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(box_expr) = option_box_expr{
                //No need to clone additional since we don't use additional_input multiple times
                #box_expr_fn_name(box_expr, #additional_input_name);
            }
        }
    }
}

// Pat
pub fn pat_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.pat;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();
    //Matches generated by matched_check!
    {
        matched_check!(syn::Pat::Const(syn::PatConst{
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub block: Block,
        }));
        matched_check!(syn::Pat::Ident(syn::PatIdent{
            pub attrs: Vec<Attribute>,
            pub by_ref: Option<Token![ref]>,
            pub mutability: Option<Token![mut]>,
            pub ident: Ident,
            pub subpat: Option<(Token![@], Box<Pat>)>,

        }));
        matched_check!(syn::Pat::Lit(syn::ExprLit{
            pub attrs: Vec<Attribute>,
            pub lit: Lit,
        }));
        matched_check!(syn::Pat::Macro(syn::ExprMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
        }));
        matched_check!(syn::Pat::Or(syn::PatOr{
            pub attrs: Vec<Attribute>,
            pub leading_vert: Option<Token![|]>,
            pub cases: Punctuated<Pat, Token![|]>,
        }));
        matched_check!(syn::Pat::Paren(syn::PatParen{
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub pat: Box<Pat>,
        }));
        matched_check!(syn::Pat::Path(syn::PatPath {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,
        }));
        matched_check!(syn::Pat::Range(syn::PatRange {
            pub attrs: Vec<Attribute>,
            pub start: Option<Box<Expr>>,
            pub limits: RangeLimits,
            pub end: Option<Box<Expr>>,
        }));
        matched_check!(syn::Pat::Reference(syn::PatReference {
            pub attrs: Vec<Attribute>,
            pub and_token: Token![&],
            pub mutability: Option<Token![mut]>,
            pub pat: Box<Pat>,
        }));
        matched_check!(syn::Pat::Rest(syn::PatRest {
            pub attrs: Vec<Attribute>,
            pub dot2_token: Token![..],
        }));
        matched_check!(syn::Pat::Slice(syn::PatSlice {
            pub attrs: Vec<Attribute>,
            pub bracket_token: Bracket,
            pub elems: Punctuated<Pat, Token![,]>,
        }));
        matched_check!(syn::Pat::Struct(syn::PatStruct {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,
            pub brace_token: Brace,
            pub fields: Punctuated<FieldPat, Token![,]>,
            pub rest: Option<PatRest>,
        }));
        matched_check!(syn::Pat::Tuple(syn::PatTuple {
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub elems: Punctuated<Pat, Token![,]>,
        }));
        matched_check!(syn::Pat::TupleStruct(syn::PatTupleStruct {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,
            pub paren_token: Paren,
            pub elems: Punctuated<Pat, Token![,]>,
        }));
        matched_check!(syn::Pat::Type(syn::PatType {
            pub attrs: Vec<Attribute>,
            pub pat: Box<Pat>,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
        }));
        matched_check!(syn::Pat::Wild(syn::PatWild {
            pub attrs: Vec<Attribute>,
            pub underscore_token: Token![_],
        }));
    }

    result_matches.extend(quote! {
        syn::Pat::Verbatim(_) => {
            todo!("syn::Pat::Verbatim is unsupported by all_syntax_cases macro")
        }
        i=>{
            todo!("syn::Pat not supported yet by all_syntax_cases macro | Pat: {}", i.to_token_stream())
        }
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Pat,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item {
                #result_matches
            }
        }
    }
}

// FieldPat
pub fn field_pat_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.field_pat;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();
    struct_check!(syn::FieldPat{
        pub attrs: Vec<Attribute>,
        pub member: Member,
        pub colon_token: Option<Token![:]>,
        pub pat: Box<Pat>,
    });
    quote! {
        fn #fn_name(
            search_item: &mut syn::FieldPat,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<(Token![@], Box<Pat>)>
pub fn option_at_pat(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_at_pat;
    let pat_name = &fn_names.pat;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(Token![@], Box<syn::Pat>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, box_pat)) = search_item {
                // No need to clone additional since we don't use additional_input multiple times
                #pat_name(box_pat, #additional_input_name);
            }
        }
    }
}

// Option<(Token![else], Box<Expr>)>
pub fn option_else_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_else_expr;
    let else_expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_else_expr: &mut Option<(Token![else], Box<syn::Expr>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, box_expr)) = option_else_expr{
                //No need to clone additional since we don't use additional_input multiple times
                #else_expr_fn_name(box_expr, #additional_input_name);
            }
        }
    }
}

// Arm
pub fn arm_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.arm;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();
    struct_check!(syn::Arm{
        pub attrs: Vec<Attribute>,
        pub pat: Pat,
        pub guard: Option<(Token![if], Box<Expr>)>,
        pub fat_arrow_token: Token![=>],
        pub body: Box<Expr>,
        pub comma: Option<Token![,]>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Arm,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// arm_guard: Option<(Token![if], Box<Expr>)>
pub fn arm_guard_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.arm_guard;
    let expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(Token![if], Box<syn::Expr>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, ex)) = search_item{
                //No need to clone additional since we don't use additional_input multiple times
                #expr_fn_name(ex, #additional_input_name);
            }
        }
    }
}

// AngleBracketedGenericArguments
pub fn angle_bracketed_generic_arguments_search(
    macro_data: &mut MacroData,
) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.angle_bracketed_generic_arguments;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::AngleBracketedGenericArguments{
        pub colon2_token: Option<Token![::]>,
        pub lt_token: Token![<],
        pub args: Punctuated<GenericArgument, Token![,]>,
        pub gt_token: Token![>],
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::AngleBracketedGenericArguments,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<AngleBracketedGenericArguments>
pub fn option_angle_bracketed_generic_arguments_search(
    macro_data: &mut MacroData,
) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_angle_bracketed_generic_arguments;
    let angle_bracketed_generic_arguments_fn_name = &fn_names.angle_bracketed_generic_arguments;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            search_item: &mut Option<syn::AngleBracketedGenericArguments>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item{
                //No need to clone additional since we don't use additional_input multiple times
                #angle_bracketed_generic_arguments_fn_name(search_item, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.angle_bracketed_generic_arguments);

    final_result
}

// GenericArgument
pub fn generic_argument_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.generic_argument;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::GenericArgument::Lifetime(syn::Lifetime {
            pub apostrophe: Span,
            pub ident: Ident,
        }));
        matched_check_no_fields!(syn::GenericArgument::Type(syn::Type));
        matched_check_no_fields!(syn::GenericArgument::Const(syn::Expr));
        matched_check!(syn::GenericArgument::AssocType(syn::AssocType {
            pub ident: Ident,
            pub generics: Option<AngleBracketedGenericArguments>,
            pub eq_token: Token![=],
            pub ty: Type,
        }));
        matched_check!(syn::GenericArgument::AssocConst(syn::AssocConst {
            pub ident: Ident,
            pub generics: Option<AngleBracketedGenericArguments>,
            pub eq_token: Token![=],
            pub value: Expr,
        }));
        matched_check!(syn::GenericArgument::Constraint(syn::Constraint {
            pub ident: Ident,
            pub generics: Option<AngleBracketedGenericArguments>,
            pub colon_token: Token![:],
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
        }));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::GenericArgument,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
                i=>{
                    todo!("syn::GenericArgument not supported yet by all_syntax_cases macro | GenericArgument: {}", i.to_token_stream())
                }
            }
        }
    }
}

// Type
pub fn type_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.ty;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Type::Array(syn::TypeArray{
            pub bracket_token: Bracket,
            pub elem: Box<Type>,
            pub semi_token: Token![;],
            pub len: Expr,
        }));
        matched_check!(syn::Type::BareFn(syn::TypeBareFn{
            pub lifetimes: Option<BoundLifetimes>,
            pub unsafety: Option<Token![unsafe]>,
            pub abi: Option<Abi>,
            pub fn_token: Token![fn],
            pub paren_token: Paren,
            pub inputs: Punctuated<BareFnArg, Token![,]>,
            pub variadic: Option<BareVariadic>,
            pub output: ReturnType,
        }));
        matched_check!(syn::Type::Group(syn::TypeGroup{
            pub group_token: Group,
            pub elem: Box<Type>,
        }));
        matched_check!(syn::Type::ImplTrait(syn::TypeImplTrait{
            pub impl_token: Token![impl],
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
        }));
        matched_check!(syn::Type::Infer(syn::TypeInfer{
            pub underscore_token: Token![_],
        }));
        matched_check!(syn::Type::Macro(syn::TypeMacro{
            pub mac: Macro,
        }));
        matched_check!(syn::Type::Never(syn::TypeNever{
            pub bang_token: Token![!],
        }));
        matched_check!(syn::Type::Paren(syn::TypeParen{
            pub paren_token: Paren,
            pub elem: Box<Type>,
        }));
        matched_check!(syn::Type::Path(syn::TypePath{
            pub qself: Option<QSelf>,
            pub path: Path,
        }));
        matched_check!(syn::Type::Ptr(syn::TypePtr{
            pub star_token: Token![*],
            pub const_token: Option<Token![const]>,
            pub mutability: Option<Token![mut]>,
            pub elem: Box<Type>,
        }));
        matched_check!(syn::Type::Reference(syn::TypeReference{
            pub and_token: Token![&],
            pub lifetime: Option<Lifetime>,
            pub mutability: Option<Token![mut]>,
            pub elem: Box<Type>,
        }));
        matched_check!(syn::Type::Slice(syn::TypeSlice{
            pub bracket_token: Bracket,
            pub elem: Box<Type>,
        }));
        matched_check!(syn::Type::TraitObject(syn::TypeTraitObject{
            pub dyn_token: Option<Token![dyn]>,
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
        }));
        matched_check!(syn::Type::Tuple(syn::TypeTuple{
            pub paren_token: Paren,
            pub elems: Punctuated<Type, Token![,]>,
        }));
    }

    result_matches.extend(quote! {
        syn::Type::Verbatim(token_stream) => {
            todo!("syn::Type::Verbatim is unsupported by all_syntax_cases macro")
        }
        i=>{
            todo!("syn::Type not supported yet by all_syntax_cases macro | Type: {}", i.to_token_stream())
        }
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Type,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
            }
        }
    }
}

// Option<Type>
pub fn option_type_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_ty;
    let type_fn_name = &fn_names.ty;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<syn::Type>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item{
                //No need to clone additional since we don't use additional_input multiple times
                #type_fn_name(search_item, #additional_input_name);
            }
        }
    }
}

// BareFnArg
pub fn bare_fn_arg_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.bare_fn_arg;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();
    struct_check!(syn::BareFnArg{
        pub attrs: Vec<Attribute>,
        pub name: Option<(Ident, Token![:])>,
        pub ty: Type,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::BareFnArg,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// ReturnType
pub fn return_type_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.return_type;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check_no_fields!(syn::ReturnType::Type(Token![->], Box<Type>));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::ReturnType,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                syn::ReturnType::Default=>{}
                #result_matches
            }
        }
    }
}

// Variant
pub fn variant_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.variant;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Variant{
        pub attrs: Vec<Attribute>,

        /// Name of the variant.
        pub ident: Ident,

        /// Content stored in the variant.
        pub fields: Fields,

        /// Explicit discriminant: `Variant = 1`
        pub discriminant: Option<(Token![=], Expr)>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Variant,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// ForeignItem
pub fn foreign_item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.foreign_item;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        // Fn(ForeignItemFn),
        // Static(ForeignItemStatic),
        // Type(ForeignItemType),
        // Macro(ForeignItemMacro),
        // Verbatim(TokenStream),
        matched_check!(syn::ForeignItem::Fn(syn::ForeignItemFn{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub sig: Signature,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ForeignItem::Static(syn::ForeignItemStatic{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub static_token: Token![static],
            pub mutability: StaticMutability,
            pub ident: Ident,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ForeignItem::Type(syn::ForeignItemType{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ForeignItem::Macro(syn::ForeignItemMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    result_matches.extend(quote! {
        syn::ForeignItem::Verbatim(_) => {
            todo!("syn::ForeignItem::Verbatim is unsupported by all_syntax_cases macro")
        }
        i=>{
            todo!("syn::ForeignItem not supported yet by all_syntax_cases macro | ForeignItem: {}", i.to_token_stream())
        }
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::ForeignItem,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
            }
        }
    }
}

// QSelf
pub fn qself_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.qself;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::QSelf{
        pub lt_token: Token![<],
        pub ty: Box<Type>,
        pub position: usize,
        pub as_token: Option<Token![as]>,
        pub gt_token: Token![>],
    });

    quote! {
        fn #fn_name(
            qself: &mut syn::QSelf,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<QSelf>
pub fn option_qself_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_qself;
    let qself_fn_name = &fn_names.qself;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            option_qself: &mut Option<syn::QSelf>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(qself) = option_qself{
                //No need to clone additional since we don't use additional_input multiple times
                #qself_fn_name(qself, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.qself);

    final_result
}

// Option<(Token![=], Type)>
pub fn option_eq_type_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_eq_type;
    let type_fn_name = &fn_names.ty;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_eq_type: &mut Option<(Token![=], Box<syn::Type>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, box_ty)) = option_eq_type{
                //No need to clone additional since we don't use additional_input multiple times
                #type_fn_name(box_ty, #additional_input_name);
            }
        }
    }
}

// FieldValue
pub fn field_value_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.field_value;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::FieldValue{
        pub attrs: Vec<Attribute>,
        pub member: Member,

        /// The colon in `Struct { x: x }`. If written in shorthand like
        /// `Struct { x }`, there is no colon.
        pub colon_token: Option<Token![:]>,

        pub expr: Expr,
    });

    quote! {
        fn #fn_name(
            item_search: &mut syn::FieldValue,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// LocalInit
pub fn local_init_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.local_init;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();
    struct_check!(syn::LocalInit{
        pub eq_token: Token![=],
        pub expr: Box<Expr>,
        pub diverge: Option<(Token![else], Box<Expr>)>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::LocalInit,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}

// Option<LocalInit>
pub fn option_local_init_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.option_local_init;
    let local_init_fn_name = &fn_names.local_init;
    let additional_input_name = &fn_names.additional_input_name;

    let final_result = quote! {
        fn #fn_name(
            option_local_init: &mut Option<syn::LocalInit>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(local_init) = option_local_init{
                //No need to clone additional since we don't use additional_input multiple times
                #local_init_fn_name(local_init, #additional_input_name);
            }
        }
    };

    //Function is not used outside of this
    macro_data.system_fn_used(|fn_names| &fn_names.local_init);

    final_result
}

pub fn search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let mut result = proc_macro2::TokenStream::new();

    result.extend(item_search(macro_data));
    result.extend(expr_search(macro_data));
    result.extend(option_expr_search(macro_data));
    result.extend(block_search(macro_data));
    result.extend(stmt_search(macro_data));
    result.extend(bound_lifetimes_search(macro_data));
    result.extend(option_bound_lifetimes_search(macro_data));
    result.extend(type_param_bound_search(macro_data));
    result.extend(generic_param_search(macro_data));
    result.extend(where_predicate_search(macro_data));
    result.extend(where_clause_search(macro_data));
    result.extend(option_where_clause_search(macro_data));
    result.extend(generics_search(macro_data));
    result.extend(impl_item_search(macro_data));
    result.extend(signature_search(macro_data));
    result.extend(fn_arg_search(macro_data));
    result.extend(variadic_pat_search(macro_data));
    result.extend(variadic_search(macro_data));
    result.extend(option_variadic_search(macro_data));
    result.extend(item_mod_content_search(macro_data));
    result.extend(fields_search(macro_data));
    result.extend(field_search(macro_data));
    result.extend(trait_item_search(macro_data));
    result.extend(option_block_search(macro_data));
    result.extend(option_eq_expr_search(macro_data));
    result.extend(fields_named_search(macro_data));
    result.extend(option_box_expr_search(macro_data));
    result.extend(pat_search(macro_data));
    result.extend(field_pat_search(macro_data));
    result.extend(option_at_pat(macro_data));
    result.extend(option_else_expr_search(macro_data));
    result.extend(arm_search(macro_data));
    result.extend(arm_guard_search(macro_data));
    result.extend(angle_bracketed_generic_arguments_search(macro_data));
    result.extend(option_angle_bracketed_generic_arguments_search(macro_data));
    result.extend(generic_argument_search(macro_data));
    result.extend(type_search(macro_data));
    result.extend(option_type_search(macro_data));
    result.extend(bare_fn_arg_search(macro_data));
    result.extend(return_type_search(macro_data));
    result.extend(variant_search(macro_data));
    result.extend(foreign_item_search(macro_data));
    result.extend(qself_search(macro_data));
    result.extend(option_eq_type_search(macro_data));
    result.extend(field_value_search(macro_data));
    result.extend(local_init_search(macro_data));
    result.extend(option_local_init_search(macro_data));
    result.extend(option_qself_search(macro_data));

    result
}
