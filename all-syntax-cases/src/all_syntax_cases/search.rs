use crate::helpers::never_any;

use super::data::MacroData;
use all_syntax_cases_helpers::{matched_check, matched_check_no_fields, struct_check};
use proc_macro2::Span;
use quote::{ToTokens, quote};
use syn::{
    Abi, AngleBracketedGenericArguments, Arm, Attribute, BinOp, Block, BoundLifetimes,
    CapturedParam, Expr, Field, FieldMutability, FieldValue, Fields, FieldsNamed, FnArg,
    ForeignItem, Generics, Ident, ImplItem, ImplRestriction, Item, Label, Lifetime, Lit, LocalInit,
    Macro, Member, Pat, Path, PointerMutability, QSelf, RangeLimits, ReturnType, Signature,
    StaticMutability, Token, TraitBoundModifier, TraitItem, Type, TypeParamBound, UnOp, UseTree,
    Variadic, Variant, Visibility,
    punctuated::Punctuated,
    token::{Brace, Paren},
};
// Item
pub fn item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.item;

    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Item::Const(syn::ItemConst {
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub const_token: Token![const],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
        }));

        matched_check!(syn::Item::Enum(syn::ItemEnum{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub enum_token: Token![enum],
            pub ident: Ident,
            pub generics: Generics,
            pub brace_token: syn::token::Brace,
            pub variants: Punctuated<Variant, Token![,]>,
        }));
        matched_check!(syn::Item::ExternCrate(syn::ItemExternCrate{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub extern_token: Token![extern],
            pub crate_token: Token![crate],
            pub ident: Ident,
            pub rename: Option<(Token![as], Ident)>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Fn(syn::ItemFn{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub sig: Signature,
            pub block: Box<Block>,
        }));
        matched_check!(syn::Item::ForeignMod(syn::ItemForeignMod{
            pub attrs: Vec<Attribute>,
            pub unsafety: Option<Token![unsafe]>,
            pub abi: Abi,
            pub brace_token: syn::token::Brace,
            pub items: Vec<ForeignItem>,
        }));
        matched_check!(syn::Item::Impl(syn::ItemImpl{
            pub attrs: Vec<Attribute>,
            pub defaultness: Option<Token![default]>,
            pub unsafety: Option<Token![unsafe]>,
            pub impl_token: Token![impl],
            pub generics: Generics,
            pub trait_: Option<(Option<Token![!]>, Path, Token![for])>,
            pub self_ty: Box<Type>,
            pub brace_token: syn::token::Brace,
            pub items: Vec<ImplItem>,
        }));
        matched_check!(syn::Item::Macro(syn::ItemMacro{
            pub attrs: Vec<Attribute>,
            /// The `example` in `macro_rules! example { ... }`.
            pub ident: Option<Ident>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Mod(syn::ItemMod{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub unsafety: Option<Token![unsafe]>,
            pub mod_token: Token![mod],
            pub ident: Ident,
            pub content: Option<(syn::token::Brace, Vec<Item>)>,
            pub semi: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Static(syn::ItemStatic{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub static_token: Token![static],
            pub mutability: StaticMutability,
            pub ident: Ident,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Struct(syn::ItemStruct{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub struct_token: Token![struct],
            pub ident: Ident,
            pub generics: Generics,
            pub fields: Fields,
            pub semi_token: Option<Token![;]>,
        }));
        matched_check!(syn::Item::Trait(syn::ItemTrait{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub unsafety: Option<Token![unsafe]>,
            pub auto_token: Option<Token![auto]>,
            pub restriction: Option<ImplRestriction>,
            pub trait_token: Token![trait],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Option<Token![:]>,
            pub supertraits: Punctuated<TypeParamBound, Token![+]>,
            pub brace_token: syn::token::Brace,
            pub items: Vec<TraitItem>,
        }));
        matched_check!(syn::Item::TraitAlias(syn::ItemTraitAlias{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub trait_token: Token![trait],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Type(syn::ItemType{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub ty: Box<Type>,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::Item::Union(syn::ItemUnion{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub union_token: Token![union],
            pub ident: Ident,
            pub generics: Generics,
            pub fields: FieldsNamed,
        }));
        matched_check!(syn::Item::Use(syn::ItemUse{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub use_token: Token![use],
            pub leading_colon: Option<Token![::]>,
            pub tree: UseTree,
            pub semi_token: Token![;],
        }));
    }

    result_matches.extend(quote! {
        syn::Item::Verbatim(token_stream) => {
            todo!("syn::Item::Verbatim is unsupported by all_syntax_cases macro")
        }
        i => todo!(
            "Item not supported yet by all_syntax_cases macro | Item: {}",
            i.to_token_stream()
        ),
    });

    quote! {
        fn #fn_name(
            item: &mut syn::Item,
            #additional_input_name: #additional_input_ty,
        ) {
            match item {
                #result_matches
            }
        }
    }
}
// Expr
pub fn expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.expr;

    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Expr::Array(syn::ExprArray {
            pub attrs: Vec<Attribute>,
            pub bracket_token: syn::token::Bracket,
            pub elems: Punctuated<Expr, Token![,]>,
        }));
        matched_check!(syn::Expr::Assign(syn::ExprAssign {
            pub attrs: Vec<Attribute>,
            pub left: Box<Expr>,
            pub eq_token: Token![=],
            pub right: Box<Expr>,

        }));
        matched_check!(syn::Expr::Async(syn::ExprAsync {
            pub attrs: Vec<Attribute>,
            pub async_token: Token![async],
            pub capture: Option<Token![move]>,
            pub block: Block,
        }));
        matched_check!(syn::Expr::Await(syn::ExprAwait {
            pub attrs: Vec<Attribute>,
            pub base: Box<Expr>,
            pub dot_token: Token![.],
            pub await_token: Token![await],
        }));
        matched_check!(syn::Expr::Binary(syn::ExprBinary {
            pub attrs: Vec<Attribute>,
            pub left: Box<Expr>,
            pub op: BinOp,
            pub right: Box<Expr>,

        }));
        matched_check!(syn::Expr::Block(syn::ExprBlock {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub block: Block,

        }));
        matched_check!(syn::Expr::Break(syn::ExprBreak {
            pub attrs: Vec<Attribute>,
            pub break_token: Token![break],
            pub label: Option<Lifetime>,
            pub expr: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Call(syn::ExprCall {
            pub attrs: Vec<Attribute>,
            pub func: Box<Expr>,
            pub paren_token: Paren,
            pub args: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Cast(syn::ExprCast {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub as_token: Token![as],
            pub ty: Box<Type>,

        }));
        matched_check!(syn::Expr::Closure(syn::ExprClosure {
            pub attrs: Vec<Attribute>,
            pub lifetimes: Option<BoundLifetimes>,
            pub constness: Option<Token![const]>,
            pub movability: Option<Token![static]>,
            pub asyncness: Option<Token![async]>,
            pub capture: Option<Token![move]>,
            pub or1_token: Token![|],
            pub inputs: Punctuated<Pat, Token![,]>,
            pub or2_token: Token![|],
            pub output: ReturnType,
            pub body: Box<Expr>,

        }));
        matched_check!(syn::Expr::Const(syn::ExprConst {
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub block: Block,

        }));
        matched_check!(syn::Expr::Continue(syn::ExprContinue {
            pub attrs: Vec<Attribute>,
            pub continue_token: Token![continue],
            pub label: Option<Lifetime>,

        }));
        matched_check!(syn::Expr::Field(syn::ExprField {
            pub attrs: Vec<Attribute>,
            pub base: Box<Expr>,
            pub dot_token: Token![.],
            pub member: Member,

        }));
        matched_check!(syn::Expr::ForLoop(syn::ExprForLoop {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub for_token: Token![for],
            pub pat: Box<Pat>,
            pub in_token: Token![in],
            pub expr: Box<Expr>,
            pub body: Block,

        }));
        matched_check!(syn::Expr::Group(syn::ExprGroup {
            pub attrs: Vec<Attribute>,
            pub group_token: syn::token::Group,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::If(syn::ExprIf {
            pub attrs: Vec<Attribute>,
            pub if_token: Token![if],
            pub cond: Box<Expr>,
            pub then_branch: Block,
            pub else_branch: Option<(Token![else], Box<Expr>)>,

        }));
        matched_check!(syn::Expr::Index(syn::ExprIndex {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub bracket_token: syn::token::Bracket,
            pub index: Box<Expr>,

        }));
        matched_check!(syn::Expr::Infer(syn::ExprInfer {
            pub attrs: Vec<Attribute>,
            pub underscore_token: Token![_],

        }));
        matched_check!(syn::Expr::Let(syn::ExprLet {
            pub attrs: Vec<Attribute>,
            pub let_token: Token![let],
            pub pat: Box<Pat>,
            pub eq_token: Token![=],
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Lit(syn::ExprLit {
            pub attrs: Vec<Attribute>,
            pub lit: Lit,

        }));
        matched_check!(syn::Expr::Loop(syn::ExprLoop {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub loop_token: Token![loop],
            pub body: Block,

        }));
        matched_check!(syn::Expr::Macro(syn::ExprMacro {
            pub attrs: Vec<Attribute>,
            pub mac: Macro,

        }));
        matched_check!(syn::Expr::Match(syn::ExprMatch {
            pub attrs: Vec<Attribute>,
            pub match_token: Token![match],
            pub expr: Box<Expr>,
            pub brace_token: syn::token::Brace,
            pub arms: Vec<Arm>,

        }));
        matched_check!(syn::Expr::MethodCall(syn::ExprMethodCall {
            pub attrs: Vec<Attribute>,
            pub receiver: Box<Expr>,
            pub dot_token: Token![.],
            pub method: Ident,
            pub turbofish: Option<AngleBracketedGenericArguments>,
            pub paren_token: Paren,
            pub args: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Paren(syn::ExprParen {
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Path(syn::ExprPath {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,

        }));
        matched_check!(syn::Expr::Range(syn::ExprRange {
            pub attrs: Vec<Attribute>,
            pub start: Option<Box<Expr>>,
            pub limits: RangeLimits,
            pub end: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::RawAddr(syn::ExprRawAddr {
            pub attrs: Vec<Attribute>,
            pub and_token: Token![&],
            pub raw: Token![raw],
            pub mutability: PointerMutability,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Reference(syn::ExprReference {
            pub attrs: Vec<Attribute>,
            pub and_token: Token![&],
            pub mutability: Option<Token![mut]>,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Repeat(syn::ExprRepeat {
            pub attrs: Vec<Attribute>,
            pub bracket_token: syn::token::Bracket,
            pub expr: Box<Expr>,
            pub semi_token: Token![;],
            pub len: Box<Expr>,

        }));
        matched_check!(syn::Expr::Return(syn::ExprReturn {
            pub attrs: Vec<Attribute>,
            pub return_token: Token![return],
            pub expr: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Struct(syn::ExprStruct {
            pub attrs: Vec<Attribute>,
            pub qself: Option<QSelf>,
            pub path: Path,
            pub brace_token: syn::token::Brace,
            pub fields: Punctuated<FieldValue, Token![,]>,
            pub dot2_token: Option<Token![..]>,
            pub rest: Option<Box<Expr>>,

        }));
        matched_check!(syn::Expr::Try(syn::ExprTry {
            pub attrs: Vec<Attribute>,
            pub expr: Box<Expr>,
            pub question_token: Token![?],

        }));
        matched_check!(syn::Expr::TryBlock(syn::ExprTryBlock {
            pub attrs: Vec<Attribute>,
            pub try_token: Token![try],
            pub block: Block,

        }));
        matched_check!(syn::Expr::Tuple(syn::ExprTuple {
            pub attrs: Vec<Attribute>,
            pub paren_token: Paren,
            pub elems: Punctuated<Expr, Token![,]>,

        }));
        matched_check!(syn::Expr::Unary(syn::ExprUnary {
            pub attrs: Vec<Attribute>,
            pub op: UnOp,
            pub expr: Box<Expr>,

        }));
        matched_check!(syn::Expr::Unsafe(syn::ExprUnsafe {
            pub attrs: Vec<Attribute>,
            pub unsafe_token: Token![unsafe],
            pub block: Block,

        }));
        matched_check!(syn::Expr::While(syn::ExprWhile {
            pub attrs: Vec<Attribute>,
            pub label: Option<Label>,
            pub while_token: Token![while],
            pub cond: Box<Expr>,
            pub body: Block,

        }));
        matched_check!(syn::Expr::Yield(syn::ExprYield {
            pub attrs: Vec<Attribute>,
            pub yield_token: Token![yield],
            pub expr: Option<Box<Expr>>,
        }));
    }

    result_matches.extend(quote! {
        syn::Expr::Verbatim(token_stream) => {
            todo!("syn::Expr::Verbatim is unsupported by all_syntax_cases macro")
        }
        i => todo!(
            "Expr not supported yet by all_syntax_cases macro | Expr: {}",
            i.to_token_stream()
        ),
    });

    quote! {
        fn #fn_name(
            expr: &mut syn::Expr,
            #additional_input_name: #additional_input_ty,
        ) {
            match expr {
                #result_matches
            }
        }
    }
}
// Option<Expr>
pub fn option_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.expr_option;
    let fn_name_expr = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            expr: &mut Option<syn::Expr>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(ex) = expr{
                //No need to clone additional since we don't use additional_input multiple times
                #fn_name_expr(ex, #additional_input_name);
            }
        }
    }
}
// Block
pub fn block_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions: _,
        special_functions: _,
        system_functions: _,
    } = macro_data;

    let fn_name = &fn_names.block;
    let stmt_fn_name = &fn_names.stmt;

    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            block: &mut syn::Block,
            #additional_input_name: #additional_input_ty,
        ) {
            for stmt in &mut block.stmts.iter_mut(){
                #stmt_fn_name(stmt, #additional_input_name.clone());
            }
        }
    }
}
// Stmt
pub fn stmt_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.stmt;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Stmt::Local(syn::Local{
            pub attrs: Vec<Attribute>,
            pub let_token: Token![let],
            pub pat: Pat,
            pub init: Option<LocalInit>,
            pub semi_token: Token![;],
        }));
        matched_check_no_fields!(syn::Stmt::Item(syn::Item));
        matched_check_no_fields!(syn::Stmt::Expr(syn::Expr, Option<Token![;]>));
        matched_check!(syn::Stmt::Macro(syn::StmtMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    quote! {
        fn #fn_name(
            stmt: &mut syn::Stmt,
            #additional_input_name: #additional_input_ty,
        ) {
            match stmt {
                #result_matches
            }
        }
    }
}
// BoundLifetimes
pub fn bound_lifetimes_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.bound_lifetimes;
    let generic_param_fn_name = &fn_names.generic_param;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            bound_lifetimes: &mut syn::BoundLifetimes,
            #additional_input_name: #additional_input_ty,
        ) {
            for generic_param in bound_lifetimes.lifetimes.iter_mut(){
                #generic_param_fn_name(generic_param, #additional_input_name.clone());
            }
        }
    }
}
// Option<BoundLifetimes>
pub fn option_bound_lifetimes_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.bound_lifetimes_option;
    let bound_lifetimes_fn_name = &fn_names.bound_lifetimes;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            bound_lifetimes: &mut Option<syn::BoundLifetimes>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(bl) = bound_lifetimes{
                //No need to clone additional since we don't use additional_input multiple times
                #bound_lifetimes_fn_name(bl, #additional_input_name);
            }
        }
    }
}
// TypeParamBound
pub fn type_param_bound_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.type_param_bound;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::TypeParamBound::Trait(syn::TraitBound{
            pub paren_token: Option<Paren>,
            pub modifier: TraitBoundModifier,
            pub lifetimes: Option<BoundLifetimes>,
            pub path: Path,
        }));

        matched_check!(syn::TypeParamBound::Lifetime(syn::Lifetime{
            pub apostrophe: Span,
            pub ident: Ident,
        }));

        matched_check!(syn::TypeParamBound::PreciseCapture(syn::PreciseCapture{
            pub use_token: Token![use],
            pub lt_token: Token![<],
            pub params: Punctuated<CapturedParam, Token![,]>,
            pub gt_token: Token![>],
        }));
    }

    result_matches.extend(quote! {
        syn::TypeParamBound::Verbatim(_) => {
            todo!("syn::TypeParamBound::Verbatim not supported by all_syntax_cases macro")
        },
        i => {
            todo!("syn::TypeParamBound not supported yet by all_syntax_cases macro | TypeParamBound: {}", i.to_token_stream())
        },
    });

    quote! {
        fn #fn_name(
            type_param_bound: &mut syn::TypeParamBound,
            #additional_input_name: #additional_input_ty,
        ) {
            match type_param_bound {
                #result_matches
            }
        }
    }
}
// GenericParam
pub fn generic_param_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.stmt;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(TypeParamBound::Trait(syn::TraitBound{
            pub paren_token: Option<Paren>,
            pub modifier: TraitBoundModifier,
            /// The `for<'a>` in `for<'a> Foo<&'a T>`
            pub lifetimes: Option<BoundLifetimes>,
            /// The `Foo<&'a T>` in `for<'a> Foo<&'a T>`
            pub path: Path,
        }));

        matched_check!(syn::GenericParam::Lifetime(syn::LifetimeParam{
            pub attrs: Vec<Attribute>,
            pub lifetime: Lifetime,
            pub colon_token: Option<Token![:]>,
            pub bounds: Punctuated<Lifetime, Token![+]>,
        }));

        matched_check!(syn::GenericParam::Const(syn::ConstParam{
            pub attrs: Vec<Attribute>,
            pub const_token: Token![const],
            pub ident: Ident,
            pub colon_token: Token![:],
            pub ty: Type,
            pub eq_token: Option<Token![=]>,
            pub default: Option<Expr>,
        }));
    }

    quote! {
        fn #fn_name(
            generic_param: &mut syn::GenericParam,
            #additional_input_name: #additional_input_ty,
        ) {
            match generic_param {
                #result_matches
            }
        }
    }
}
// WherePredicate
pub fn where_predicate_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.where_predicate;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::WherePredicate::Lifetime(syn::PredicateLifetime{
            pub lifetime: Lifetime,
            pub colon_token: Token![:],
            pub bounds: Punctuated<Lifetime, Token![+]>,
        }));

        matched_check!(syn::WherePredicate::Type(syn::PredicateType{
            /// Any lifetimes from a `for` binding
            pub lifetimes: Option<BoundLifetimes>,
            /// The type being bounded
            pub bounded_ty: Type,
            pub colon_token: Token![:],
            /// Trait and lifetime bounds (`Clone+Send+'static`)
            pub bounds: Punctuated<TypeParamBound, Token![+]>,
        }));
    }

    quote! {
        fn #fn_name(
            where_predicate: &mut syn::WherePredicate,
            #additional_input_name: #additional_input_ty,
        ) {
            match where_predicate {
                #result_matches
            }
        }
    }
}
// Generics
pub fn generics_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.generics;
    let where_predicate_fn_name = &fn_names.where_predicate;
    let generic_param_fn_name = &fn_names.generic_param;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            generics: &mut syn::Generics,
            #additional_input_name: #additional_input_ty,
        ) {
            for param in &mut generics.params.iter_mut(){
                #generic_param_fn_name(param, #additional_input_name.clone());
            }
            if let Some(where_clause) = &mut generics.where_clause{
                #where_predicate_fn_name(where_clause, #additional_input_name.clone());
            }
        }
    }
}
// ImplItem
pub fn impl_item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.impl_item;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::ImplItem::Const(syn::ImplItemConst{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub const_token: Token![const],
            pub ident: Ident,
            pub generics: Generics,
            pub colon_token: Token![:],
            pub ty: Type,
            pub eq_token: Token![=],
            pub expr: Expr,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ImplItem::Fn(syn::ImplItemFn{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub sig: Signature,
            pub block: Block,
        }));
        matched_check!(syn::ImplItem::Type(syn::ImplItemType{
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub defaultness: Option<Token![default]>,
            pub type_token: Token![type],
            pub ident: Ident,
            pub generics: Generics,
            pub eq_token: Token![=],
            pub ty: Type,
            pub semi_token: Token![;],
        }));
        matched_check!(syn::ImplItem::Macro(syn::ImplItemMacro{
            pub attrs: Vec<Attribute>,
            pub mac: Macro,
            pub semi_token: Option<Token![;]>,
        }));
    }

    result_matches.extend(quote! {
        syn::ImplItem::Verbatim(token_stream) => {
            todo!("syn::ImplItem::Verbatim is unsupported by all_syntax_cases macro")
        }
    });

    quote! {
        fn #fn_name(
            impl_item: &mut syn::ImplItem,
            #additional_input_name: #additional_input_ty,
        ) {
            match impl_item {
                #result_matches
            }
        }
    }
}
// Signature
pub fn signature_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.signature;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Signature{
        pub constness: Option<Token![const]>,
        pub asyncness: Option<Token![async]>,
        pub unsafety: Option<Token![unsafe]>,
        pub abi: Option<Abi>,
        pub fn_token: Token![fn],
        pub ident: Ident,
        pub generics: Generics,
        pub paren_token: Paren,
        pub inputs: Punctuated<FnArg, Token![,]>,
        pub variadic: Option<Variadic>,
        pub output: ReturnType,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Signature,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// FnArg
pub fn fn_arg_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fn_arg;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    // Matches generated by matched_check!
    {
        matched_check!(syn::FnArg::Receiver(syn::Receiver{
            pub attrs: Vec<Attribute>,
            pub reference: Option<(Token![&], Option<Lifetime>)>,
            pub mutability: Option<Token![mut]>,
            pub self_token: Token![self],
            pub colon_token: Option<Token![:]>,
            pub ty: Box<Type>,
        }));
        matched_check!(syn::FnArg::Typed(syn::PatType{
            pub attrs: Vec<Attribute>,
            pub pat: Box<Pat>,
            pub colon_token: Token![:],
            pub ty: Box<Type>,
        }));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::FnArg,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                #result_matches
            }
        }
    }
}
// variadic_pat: Option<(Box<Pat>, Token![:])>,
pub fn variadic_pat_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.variadic_pat;
    let pat_fn_name = &fn_names.pat;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(Box<syn::Pat>, Token![:])>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                #pat_fn_name(&mut search_item.0, #additional_input_name);
            }
        }
    }
}
// Variadic
pub fn variadic_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.variadic;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Variadic{
        pub attrs: Vec<Attribute>,
        pub pat: Option<(Box<Pat>, Token![:])>,
        pub dots: Token![...],
        pub comma: Option<Token![,]>,
    });

    quote! {
        fn #fn_name(
            search_item: &mut syn::Variadic,
            #additional_input_name: #additional_input_ty,
        ) {
            #result
        }
    }
}
// Option<Variadic>
pub fn option_variadic_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.variadic_option;
    let variadic_fn_name = &fn_names.variadic;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<syn::Variadic>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(search_item) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                #variadic_fn_name(search_item, #additional_input_name);
            }
        }
    }
}
// item_mod_content: Option<(syn::token::Brace, Vec<Item>)>,
pub fn item_mod_content_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.item_mod_content;
    let item_fn_name = &fn_names.item;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            search_item: &mut Option<(syn::token::Brace, Vec<Item>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, items)) = search_item {
                //No need to clone additional since we don't use additional_input multiple times
                for item in items.iter_mut(){
                    #item_fn_name(item, #additional_input_name.clone());
                }
            }
        }
    }
}
// Fields
pub fn fields_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fields;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result_matches = proc_macro2::TokenStream::new();

    //Matches generated by matched_check!
    {
        matched_check!(syn::Fields::Named(syn::FieldsNamed{
            pub brace_token: Brace,
            pub named: Punctuated<Field, Token![,]>,
        }));

        matched_check!(syn::Fields::Unnamed(syn::FieldsUnnamed{
            pub paren_token: Paren,
            pub unnamed: Punctuated<Field, Token![,]>,
        }));
    }

    quote! {
        fn #fn_name(
            search_item: &mut syn::Fields,
            #additional_input_name: #additional_input_ty,
        ) {
            match search_item{
                syn::Fields::Unit => {
                    //It's kinda hard to handle no data, y'know
                },
                #result_matches
            }
        }
    }
}
// Field
pub fn field_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.field;
    let additional_input_name = &fn_names.additional_input_name;

    let mut result = proc_macro2::TokenStream::new();

    struct_check!(syn::Field{
        pub attrs: Vec<Attribute>,

        pub vis: Visibility,

        pub mutability: FieldMutability,

        /// Name of the field, if any.
        ///
        /// Fields of tuple structs have no names.
        pub ident: Option<Ident>,

        pub colon_token: Option<Token![:]>,

        pub ty: Type,
    });

    quote! {
        fn #fn_name(
            field: &mut syn::Field,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("field_search not implemented yet")
        }
    }
}

// TODO TraitItem
pub fn trait_item_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.trait_item;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            trait_item: &mut syn::TraitItem,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("trait_item_search not implemented yet")
        }
    }
}

// TODO FieldsNamed
pub fn fields_named_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.fields_named;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            fields_named: &mut syn::FieldsNamed,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("fields_named_search not implemented yet")
        }
    }
}

// TODO Option<Box<Expr>>
pub fn option_box_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.option_box_expr;
    let box_expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_box_expr: &mut Option<Box<syn::Expr>>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(box_expr) = option_box_expr{
                //No need to clone additional since we don't use additional_input multiple times
                #box_expr_fn_name(box_expr, #additional_input_name);
            }
        }
    }
}

// TODO Pat
pub fn pat_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.pat;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            pat: &mut syn::Pat,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("pat_search not implemented yet")
        }
    }
}

// TODO Option<(Token![else], Box<Expr>)>
pub fn option_else_expr_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.option_else_expr;
    let else_expr_fn_name = &fn_names.expr;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_else_expr: &mut Option<(Token![else], Box<syn::Expr>)>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some((_, box_expr)) = option_else_expr{
                //No need to clone additional since we don't use additional_input multiple times
                #else_expr_fn_name(box_expr, #additional_input_name);
            }
        }
    }
}

// TODO Arm
pub fn arm_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.arm;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            arm: &mut syn::Arm,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("arm_search not implemented yet")
        }
    }
}

// TODO AngleBracketedGenericArguments
pub fn angle_bracketed_generic_arguments_search(
    macro_data: &mut MacroData,
) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.angle_bracketed_generic_arguments;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            angle_bracketed_generic_arguments: &mut syn::AngleBracketedGenericArguments,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("angle_bracketed_generic_arguments_search not implemented yet")
        }
    }
}

// TODO RangeLimits
pub fn range_limits_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.range_limits;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            range_limits: &mut syn::RangeLimits,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("range_limits_search not implemented yet")
        }
    }
}

// TODO FieldValue
pub fn field_value_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.field_value;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            field_value: &mut syn::FieldValue,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("field_value_search not implemented yet")
        }
    }
}

// TODO LocalInit
pub fn local_init_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.local_init;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            local_init: &mut syn::LocalInit,
            #additional_input_name: #additional_input_ty,
        ) {
            todo!("local_init_search not implemented yet")
        }
    }
}

// TODO Option<LocalInit>
pub fn option_local_init_search(macro_data: &mut MacroData) -> proc_macro2::TokenStream {
    let MacroData {
        fn_names,
        generated_fn_prefix: _,
        additional_input_ty,
        default_functions,
        special_functions,
        system_functions,
    } = macro_data;

    let fn_name = &fn_names.option_local_init;
    let local_init_fn_name = &fn_names.local_init;
    let additional_input_name = &fn_names.additional_input_name;

    quote! {
        fn #fn_name(
            option_local_init: &mut Option<syn::LocalInit>,
            #additional_input_name: #additional_input_ty,
        ) {
            if let Some(local_init) = option_local_init{
                //No need to clone additional since we don't use additional_input multiple times
                #local_init_fn_name(local_init, #additional_input_name);
            }
        }
    }
}

// TODO Handle Punctuated in EssentialFn check

// TODO Handle Vec in EssentialFn check

// TODO Handle multiple potential in EssentialFn check (with single argument outside of user defined data)
