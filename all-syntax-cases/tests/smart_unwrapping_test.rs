//! File generated by AI not verified by a human yet
//!
//! Tests to verify smart unwrapping works for both default_cases and special_cases

use all_syntax_cases::all_syntax_cases;
use quote::ToTokens;
use syn::parse_quote;

#[derive(Default, Debug)]
struct UnwrapTracker {
    // Track what types were successfully unwrapped
    box_expr_default: usize,
    option_expr_default: usize,
    vec_expr_default: usize,
    punctuated_expr_default: usize,

    box_expr_special: usize,
    option_expr_special: usize,
    vec_expr_special: usize,
    punctuated_expr_special: usize,

    // Track multi-field handlers
    multi_field_calls: usize,
    multi_field_option_calls: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "unwrap_test",
        additional_input_type: &mut UnwrapTracker
    }
    default_cases => {
        // 2-param handlers: should get called via smart unwrapping (Box, Vec, Punctuated)
        // and via system functions (Option)
        fn default_expr_handler(expr: &mut syn::Expr, tracker: &mut UnwrapTracker);

        // 3+ param handler: should work with Box, Vec, Punctuated but NOT with Option
        // This tests multi-field correlation
        fn multi_field_handler(
            attrs: &mut Vec<syn::Attribute>,
            generics: &mut syn::Generics,
            tracker: &mut UnwrapTracker
        );

        fn const_param_handler(ty:&mut syn::Type, expr: &mut syn::Expr, tracker: &mut UnwrapTracker);
    }
    special_cases => {
        // These should also benefit from smart unwrapping
        fn special_binary_handler(binary: &mut syn::ExprBinary, tracker: &mut UnwrapTracker);
    }
}

fn default_expr_handler(expr: &mut syn::Expr, tracker: &mut UnwrapTracker) {
    // Track that we were called
    match expr {
        syn::Expr::Lit(_) => tracker.option_expr_default += 1,
        syn::Expr::Binary(_) => {} // Handled by special case
        _ => tracker.box_expr_default += 1,
    }
}

fn multi_field_handler(
    _attrs: &mut Vec<syn::Attribute>,
    _generics: &mut syn::Generics,
    tracker: &mut UnwrapTracker,
) {
    // This should be called for nodes that have both attrs and generics
    tracker.multi_field_calls += 1;
}

fn const_param_handler(_ty: &mut syn::Type, _expr: &mut syn::Expr, tracker: &mut UnwrapTracker) {
    // This should be called for ConstParam which has:
    // - ty: Type (required)
    // - default: Option<Expr> (optional)
    //
    // When Option<Expr> is Some, system function unwraps it, enabling this match!
    // Also called for other nodes that have both Type and Expr fields
    tracker.multi_field_option_calls += 1;
    eprintln!(
        "const_param_handler called! Count now: {}",
        tracker.multi_field_option_calls
    );
}

fn special_binary_handler(_binary: &mut syn::ExprBinary, tracker: &mut UnwrapTracker) {
    tracker.box_expr_special += 1;
}

// Test that default_cases work with Box unwrapping
#[test]
fn test_default_box_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // ExprUnary contains `Box<Expr>` - should unwrap and call default_expr_handler
    let mut expr: syn::Expr = parse_quote! { !true };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    // The traversal should have processed the inner Expr
    // This test verifies the macro compiles and runs without panics
}

// Test that default_cases work with Option unwrapping
#[test]
fn test_default_option_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // ExprIf may contain `Option<Box<Expr>>` in else clause - should unwrap
    let mut expr: syn::Expr = parse_quote! { if x { 1 } else { 2 } };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    // Should process without panicking
}

// Test that default_cases work with Vec unwrapping
#[test]
fn test_default_vec_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // ExprTuple contains `Vec<Expr>` via Punctuated - should unwrap and iterate
    let mut expr: syn::Expr = parse_quote! { (1, 2, 3) };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    // Should process all tuple elements
}

// Test that special_cases work with Box unwrapping
#[test]
fn test_special_box_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // ExprBinary is a special case - when it contains Box<Expr>, should still work
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    assert_eq!(
        tracker.box_expr_special, 1,
        "Special handler should be called for binary expr"
    );
}

// Test that special_cases work with nested structures
#[test]
fn test_special_nested_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // More complex expression with binary operations
    let mut expr: syn::Expr = parse_quote! { (1 + 2) * (3 - 4) };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    // Should handle multiple binary expressions via unwrapping
    assert!(
        tracker.box_expr_special >= 1,
        "Should process at least one binary expr"
    );
}

// Test Punctuated unwrapping with default_cases
#[test]
fn test_default_punctuated_unwrap() {
    let mut tracker = UnwrapTracker::default();

    // Function call with multiple arguments (Punctuated)
    let mut expr: syn::Expr = parse_quote! { func(a, b, c) };
    unwrap_test_expr_handle(&mut expr, &mut tracker);

    // Should iterate through Punctuated arguments
}

// ========== ConstParam Multi-Field Tests (Type + Option<Expr>) ==========

// This test documents the ACTUAL behavior:
// Option<Expr> fields do NOT enable multi-field correlation!
#[test]
fn test_const_param_option_limitation() {
    let mut tracker = UnwrapTracker::default();

    // ConstParam with default: has ty: Type and default: Option<Expr>
    // Our handler signature: fn(ty: &mut Type, expr: &mut Expr, ...)
    //
    // ConstParam structure:
    // - ty: Type (required)
    // - default: Option<Expr> (optional, and wrapped in Option!)
    //
    // The handler will NOT match ConstParam even when default is Some
    // because Option<Expr> doesn't support multi-field matching
    let mut item: syn::Item = parse_quote! {
        struct Simple<const N: usize = 42>;
    };

    let count_before = tracker.multi_field_option_calls;
    unwrap_test_item_handle(&mut item, &mut tracker);
    let count_after = tracker.multi_field_option_calls;

    eprintln!("Calls before: {}, after: {}", count_before, count_after);

    // The handler might get called from other nodes (like array types),
    // but NOT from ConstParam with Option<Expr>
    // This test just verifies it compiles and runs
}

// Test showing where const_param_handler DOES get called from
#[test]
fn test_const_param_handler_actual_matches() {
    let mut tracker = UnwrapTracker::default();

    // The handler (ty: Type, expr: Expr) might match other nodes
    // For example, in array repeat expressions: [value; count]
    // where we have both a type context and an expression
    let mut item: syn::Item = parse_quote! {
        struct Foo {
            data: [u8; 10]  // Has Type (u8) and Expr (10) in same context
        }
    };

    unwrap_test_item_handle(&mut item, &mut tracker);

    // Handler gets called from contexts that have both Type and Expr
    // (but NOT from ConstParam with Option<Expr>)
    eprintln!("Handler called {} times", tracker.multi_field_option_calls);
}

//Test showing the limitation clearly
#[test]
fn test_option_expr_multi_field_limitation() {
    let mut tracker = UnwrapTracker::default();

    // Even with default value present, ConstParam won't match our multi-field handler
    let mut item: syn::Item = parse_quote! {
        struct WithDefault<const N: usize = 100>;
    };
    unwrap_test_item_handle(&mut item, &mut tracker);
    let with_default_count = tracker.multi_field_option_calls;

    let mut tracker2 = UnwrapTracker::default();
    let mut item2: syn::Item = parse_quote! {
        struct WithoutDefault<const N: usize>;
    };
    unwrap_test_item_handle(&mut item2, &mut tracker2);
    let without_default_count = tracker2.multi_field_option_calls;

    // Both should have the same count because ConstParam doesn't contribute
    // (its Expr is wrapped in Option, which doesn't support multi-field matching)
    assert_eq!(
        with_default_count, without_default_count,
        "ConstParam with/without default should have same count (Option<Expr> limitation)"
    );
}
