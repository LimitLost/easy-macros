//! File generated by AI not verified by a human yet
//!
//! Test file to verify all claims made in the comparison documentation
//! Each test validates a specific documented behavior by actually running the macro

use easy_macros_all_syntax_cases::all_syntax_cases;
use quote::ToTokens;
use syn::parse_quote;
use syn::visit_mut::{self, VisitMut};

// ====================================================================================
// Test 1: Multi-parameter matching with Vec<Attribute> + Generics
// ====================================================================================

#[derive(Default, Debug)]
struct Test1Context {
    calls: Vec<String>,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test1",
        additional_input_type: &mut Test1Context,
    }
    default_cases => {
        fn test1_check_attrs_generics(
            attrs: &mut Vec<syn::Attribute>,
            generics: &mut syn::Generics,
            ctx: &mut Test1Context
        );
    }
    special_cases => {}
}

fn test1_check_attrs_generics(
    attrs: &mut Vec<syn::Attribute>,
    generics: &mut syn::Generics,
    ctx: &mut Test1Context,
) {
    // Record that we received a Vec with multiple attributes
    ctx.calls.push(format!(
        "attrs_len={}, has_generics={}",
        attrs.len(),
        !generics.params.is_empty()
    ));
}

/// Test: Multi-parameter handler receives entire Vec, not per-element iteration
#[test]
fn test_multi_param_receives_whole_vec() {
    let mut ctx = Test1Context::default();
    let mut item: syn::ItemStruct = parse_quote! {
        #[derive(Debug)]
        #[serde(rename = "test")]
        struct Foo<T> {
            field: T
        }
    };

    test1_item_handle(&mut syn::Item::Struct(item), &mut ctx);

    println!("Multi-param test calls: {:?}", ctx.calls);

    // Verify: Should be called once with attrs_len=2
    assert_eq!(
        ctx.calls.len(),
        1,
        "Handler should be called once, not per attribute"
    );
    assert!(
        ctx.calls[0].contains("attrs_len=2"),
        "Should receive entire Vec with 2 attributes"
    );
}

// ====================================================================================
// Test 2: Single parameter with Vec - should iterate
// ====================================================================================

#[derive(Default, Debug)]
struct Test2Context {
    attr_count: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test2",
        additional_input_type: &mut Test2Context
    }
    default_cases => {
        fn test2_count_attrs(attr: &mut syn::Attribute, ctx: &mut Test2Context);
    }
    special_cases => {}
}

fn test2_count_attrs(attr: &mut syn::Attribute, ctx: &mut Test2Context) {
    ctx.attr_count += 1;
}

/// Test: Single-param handler iterates over Vec<Attribute>
#[test]
fn test_single_param_iterates_vec() {
    let mut ctx = Test2Context::default();
    let mut item: syn::ItemStruct = parse_quote! {
        #[derive(Debug)]
        #[serde(rename = "test")]
        #[allow(dead_code)]
        struct Foo {
            field: String
        }
    };

    test2_item_handle(&mut syn::Item::Struct(item), &mut ctx);

    println!("Single-param iteration test: attr_count={}", ctx.attr_count);

    // Should be called 3 times (once per attribute)
    assert_eq!(
        ctx.attr_count, 3,
        "Handler should be called once per attribute"
    );
}

// ====================================================================================
// Test 3: Box unwrapping
// ====================================================================================

#[derive(Default, Debug)]
struct Test3Context {
    expr_count: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test3",
        additional_input_type: &mut Test3Context
    }
    default_cases => {
        fn test3_count_exprs(expr: &mut syn::Expr, ctx: &mut Test3Context);
    }
    special_cases => {}
}

fn test3_count_exprs(expr: &mut syn::Expr, ctx: &mut Test3Context) {
    ctx.expr_count += 1;
}

/// Test: &mut Expr parameter matches Box<Expr> field
#[test]
fn test_box_unwrapping() {
    let mut ctx = Test3Context::default();
    // ExprBinary has Box<Expr> fields for left and right
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };

    test3_expr_handle(&mut expr, &mut ctx);

    println!("Box unwrapping test: expr_count={}", ctx.expr_count);

    // Reality check: Actually counts left (1) + right (2) = 2
    // The handler matches the Box<Expr> fields but system calls handler on their contents,
    // not on the parent ExprBinary variant itself
    assert_eq!(
        ctx.expr_count, 2,
        "Should unwrap Box<Expr> fields and call handler on their contents"
    );
}

// ====================================================================================
// Test 4: Option handling
// ====================================================================================

#[derive(Default, Debug)]
struct Test4Context {
    expr_count: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test4",
        additional_input_type: &mut Test4Context
    }
    default_cases => {
        fn test4_count_exprs(expr: &mut syn::Expr, ctx: &mut Test4Context);
    }
    special_cases => {}
}

fn test4_count_exprs(expr: &mut syn::Expr, ctx: &mut Test4Context) {
    ctx.expr_count += 1;
}

/// Test: System generates if-let for Option<T> and calls T handler
#[test]
fn test_option_automatic_handling() {
    let mut ctx = Test4Context::default();
    // ExprBreak has Option<Box<Expr>> field
    let mut expr: syn::Expr = parse_quote! { break Some(42) };

    test4_expr_handle(&mut expr, &mut ctx);

    println!("Option handling test: expr_count={}", ctx.expr_count);

    // Should count: break expr + inner expr (42) = 2
    assert!(
        ctx.expr_count >= 2,
        "Should automatically traverse into Option<Expr> when Some"
    );
}

// ====================================================================================
// Test 5: Special case overrides default
// ====================================================================================

#[derive(Default, Debug)]
struct Test5Context {
    default_count: usize,
    special_count: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test5",
        additional_input_type: &mut Test5Context
    }
    default_cases => {
        fn test5_count_all_exprs(expr: &mut syn::Expr, ctx: &mut Test5Context);
    }
    special_cases => {
        fn test5_handle_try_special(expr_try: &mut syn::ExprTry, ctx: &mut Test5Context);
    }
}

fn test5_count_all_exprs(expr: &mut syn::Expr, ctx: &mut Test5Context) {
    ctx.default_count += 1;
}

fn test5_handle_try_special(expr_try: &mut syn::ExprTry, ctx: &mut Test5Context) {
    ctx.special_count += 1;
    // Deliberately NOT calling test5_expr_handle to test traversal stopping
}

/// Test: When special case matches, default handler is NOT called
#[test]
fn test_special_overrides_default() {
    let mut ctx = Test5Context::default();
    let mut expr: syn::Expr = parse_quote! { foo()? };

    test5_expr_handle(&mut expr, &mut ctx);

    println!(
        "Special override test: default={}, special={}",
        ctx.default_count, ctx.special_count
    );

    assert_eq!(
        ctx.special_count, 1,
        "Special handler should be called for ExprTry"
    );
    assert_eq!(
        ctx.default_count, 0,
        "Default handler should NOT be called when special case matches"
    );
}

// ====================================================================================
// Test 6: #[after_system] execution order
// ====================================================================================

#[derive(Default, Debug)]
struct Test6Context {
    events: Vec<String>,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test6",
        additional_input_type: &mut Test6Context
    }
    default_cases => {
        fn test6_before_handler(expr: &mut syn::Expr, ctx: &mut Test6Context);

        #[after_system]
        fn test6_after_handler(expr: &mut syn::Expr, ctx: &mut Test6Context);
    }
    special_cases => {}
}

fn test6_before_handler(expr: &mut syn::Expr, ctx: &mut Test6Context) {
    use quote::ToTokens;
    ctx.events.push(format!(
        "BEFORE: {}",
        expr.to_token_stream()
            .to_string()
            .chars()
            .take(10)
            .collect::<String>()
    ));
}

fn test6_after_handler(expr: &mut syn::Expr, ctx: &mut Test6Context) {
    use quote::ToTokens;
    ctx.events.push(format!(
        "AFTER: {}",
        expr.to_token_stream()
            .to_string()
            .chars()
            .take(10)
            .collect::<String>()
    ));
}

/// Test: after_system handlers run AFTER system traversal
#[test]
fn test_after_system_ordering() {
    let mut ctx = Test6Context::default();
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };

    test6_expr_handle(&mut expr, &mut ctx);

    println!("After-system ordering test events:\n{:#?}", ctx.events);

    // Reality: Handler is called on leaf nodes (literals "1" and "2"), not parent ExprBinary
    // Verify that for EACH expression node, BEFORE comes before AFTER
    assert!(
        ctx.events.len() >= 4,
        "Should have BEFORE and AFTER for at least 2 expressions"
    );

    // Check that BEFORE entries come before their corresponding AFTER entries
    let before_1 = ctx
        .events
        .iter()
        .position(|e| e.starts_with("BEFORE: 1"))
        .unwrap();
    let after_1 = ctx
        .events
        .iter()
        .position(|e| e.starts_with("AFTER: 1"))
        .unwrap();
    assert!(
        after_1 > before_1,
        "AFTER should come after BEFORE for literal '1'"
    );

    let before_2 = ctx
        .events
        .iter()
        .position(|e| e.starts_with("BEFORE: 2"))
        .unwrap();
    let after_2 = ctx
        .events
        .iter()
        .position(|e| e.starts_with("AFTER: 2"))
        .unwrap();
    assert!(
        after_2 > before_2,
        "AFTER should come after BEFORE for literal '2'"
    );
}

// ====================================================================================
// Test 7: Traversal stops in special cases
// ====================================================================================

#[derive(Default, Debug)]
struct Test7Context {
    expr_count: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "test7",
        additional_input_type: &mut Test7Context
    }
    default_cases => {
        fn test7_count_exprs(expr: &mut syn::Expr, ctx: &mut Test7Context);
    }
    special_cases => {
        fn test7_handle_binary(binary: &mut syn::ExprBinary, ctx: &mut Test7Context);
    }
}

fn test7_count_exprs(expr: &mut syn::Expr, ctx: &mut Test7Context) {
    ctx.expr_count += 1;
}

fn test7_handle_binary(binary: &mut syn::ExprBinary, ctx: &mut Test7Context) {
    ctx.expr_count += 1000; // Mark that special case was called
    // NOT calling test7_expr_handle on left/right - traversal should stop
}

/// Test: Special case handlers don't automatically traverse children
#[test]
fn test_traversal_stops_in_special() {
    let mut ctx = Test7Context::default();
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };

    test7_expr_handle(&mut expr, &mut ctx);

    println!("Traversal stop test: expr_count={}", ctx.expr_count);

    // Should be 1000 (special case only), NOT 1002 (which would mean children were visited)
    assert_eq!(
        ctx.expr_count, 1000,
        "Children should NOT be visited when special case doesn't call system handler"
    );
}

// ====================================================================================
// syn::visit_mut Comparison Tests
// ====================================================================================

/// Test: syn::visit_mut cannot access multiple fields together
/// This demonstrates the limitation mentioned in documentation
#[test]
fn test_syn_visit_mut_cannot_correlate_fields() {
    #[derive(Default, Debug)]
    struct CorrelationAttempt {
        attrs_seen: Vec<String>,
        generics_seen: Vec<String>,
        // This can't work: no way to correlate which attrs belong to which generics
        correlations: Vec<(String, String)>,
    }

    impl VisitMut for CorrelationAttempt {
        fn visit_attributes_mut(&mut self, attrs: &mut Vec<syn::Attribute>) {
            for attr in attrs {
                if let Some(ident) = attr.meta.path().get_ident() {
                    self.attrs_seen.push(ident.to_string());
                }
                // Call the default visitor for each attribute
                self.visit_attribute_mut(attr);
            }
        }

        fn visit_generics_mut(&mut self, generics: &mut syn::Generics) {
            for param in &generics.params {
                if let syn::GenericParam::Type(type_param) = param {
                    self.generics_seen.push(type_param.ident.to_string());
                }
            }
            visit_mut::visit_generics_mut(self, generics);
        }
    }

    let mut visitor = CorrelationAttempt::default();
    let mut item: syn::Item = parse_quote! {
        #[derive(Debug)]
        #[serde(rename = "test")]
        struct Foo<T, U> {
            field: T
        }
    };

    visitor.visit_item_mut(&mut item);

    println!("syn::visit_mut correlation test:");
    println!("  attrs_seen: {:?}", visitor.attrs_seen);
    println!("  generics_seen: {:?}", visitor.generics_seen);

    // We can see both, but have NO WAY to know they came from the same struct
    assert!(visitor.attrs_seen.contains(&"derive".to_string()));
    assert!(visitor.attrs_seen.contains(&"serde".to_string()));
    assert!(visitor.generics_seen.contains(&"T".to_string()));
    assert!(visitor.generics_seen.contains(&"U".to_string()));

    // This is the limitation: impossible to correlate which attrs belong to which generics
    assert_eq!(
        visitor.correlations.len(),
        0,
        "Cannot correlate fields that come from same syntax node"
    );
}

/// Test: syn::visit_mut requires manual traversal calls
/// This demonstrates that overriding a visit method stops automatic traversal
#[test]
fn test_syn_visit_mut_requires_manual_traversal() {
    #[derive(Default, Debug)]
    struct ManualTraversalTest {
        try_count: usize,
        inner_expr_count: usize,
    }

    impl VisitMut for ManualTraversalTest {
        fn visit_expr_mut(&mut self, expr: &mut syn::Expr) {
            if let syn::Expr::Try(_) = expr {
                // Don't count here, let visit_expr_try_mut handle it
            } else {
                self.inner_expr_count += 1;
            }
            visit_mut::visit_expr_mut(self, expr);
        }

        fn visit_expr_try_mut(&mut self, expr_try: &mut syn::ExprTry) {
            self.try_count += 1;
            // Deliberately NOT calling visit_mut::visit_expr_try_mut(self, expr_try)
            // This should stop traversal into the inner expression
        }
    }

    let mut visitor = ManualTraversalTest::default();
    let mut expr: syn::Expr = parse_quote! { foo()? };

    visitor.visit_expr_mut(&mut expr);

    println!("syn::visit_mut manual traversal test:");
    println!("  try_count: {}", visitor.try_count);
    println!("  inner_expr_count: {}", visitor.inner_expr_count);

    assert_eq!(visitor.try_count, 1, "Should visit the try expression");
    assert_eq!(
        visitor.inner_expr_count, 0,
        "Should NOT visit inner expr when manual traversal is omitted"
    );

    // Now test WITH manual traversal
    #[derive(Default, Debug)]
    struct WithManualTraversal {
        try_count: usize,
        inner_expr_count: usize,
    }

    impl VisitMut for WithManualTraversal {
        fn visit_expr_mut(&mut self, expr: &mut syn::Expr) {
            if let syn::Expr::Try(_) = expr {
                // Don't count here, let visit_expr_try_mut handle it
            } else {
                self.inner_expr_count += 1;
            }
            visit_mut::visit_expr_mut(self, expr);
        }

        fn visit_expr_try_mut(&mut self, expr_try: &mut syn::ExprTry) {
            self.try_count += 1;
            // Manually continue traversal
            visit_mut::visit_expr_try_mut(self, expr_try);
        }
    }

    let mut visitor2 = WithManualTraversal::default();
    let mut expr2: syn::Expr = parse_quote! { foo()? };

    visitor2.visit_expr_mut(&mut expr2);

    println!("WITH manual traversal:");
    println!("  try_count: {}", visitor2.try_count);
    println!("  inner_expr_count: {}", visitor2.inner_expr_count);

    assert_eq!(visitor2.try_count, 1, "Should visit the try expression");
    assert_eq!(
        visitor2.inner_expr_count, 2,
        "Should visit inner expr when manual traversal is called"
    );
}

/// Test: syn::visit_mut has no default/special case separation
/// Every override is a "special case" - no way to have default handlers that still run
#[test]
fn test_syn_visit_mut_no_default_special_separation() {
    #[derive(Default, Debug)]
    struct NoDefaultSpecialSeparation {
        all_exprs: usize,
        try_exprs: usize,
    }

    impl VisitMut for NoDefaultSpecialSeparation {
        // This is supposed to be a "default" handler for ALL expressions
        fn visit_expr_mut(&mut self, expr: &mut syn::Expr) {
            self.all_exprs += 1;
            visit_mut::visit_expr_mut(self, expr);
        }

        // This is supposed to be a "special" handler for just ExprTry
        fn visit_expr_try_mut(&mut self, expr_try: &mut syn::ExprTry) {
            self.try_exprs += 1;
            visit_mut::visit_expr_try_mut(self, expr_try);
        }
    }

    let mut visitor = NoDefaultSpecialSeparation::default();
    let mut expr: syn::Expr = parse_quote! { foo()? };

    visitor.visit_expr_mut(&mut expr);

    println!("syn::visit_mut no default/special separation test:");
    println!("  all_exprs: {}", visitor.all_exprs);
    println!("  try_exprs: {}", visitor.try_exprs);

    // The problem: visit_expr_mut is called for the try expression BEFORE visit_expr_try_mut
    // So the "default" handler runs for ALL expressions including the "special" ones
    // Unlike all_syntax_cases where special cases completely override defaults
    assert_eq!(
        visitor.try_exprs, 1,
        "Special handler called for try expression"
    );
    assert!(
        visitor.all_exprs >= 1,
        "Default handler also called for try expression"
    );

    // In syn::visit_mut, there's no way to say "handle all expressions EXCEPT try expressions with a default, and handle try expressions specially"
    // Both handlers run for ExprTry, which is different from all_syntax_cases! behavior
}
