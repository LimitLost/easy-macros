//! File generated by AI not verified by a human yet
//!
//! Comprehensive tests to verify smart unwrapping behavior and limitations

use all_syntax_cases::all_syntax_cases;
use quote::ToTokens;
use syn::parse_quote;

#[derive(Default, Debug)]
struct Tracker {
    // Track 2-param handler calls
    expr_calls: usize,
    block_calls: usize,
    type_calls: usize,

    // Track 3+ param handler calls (multi-field correlation)
    multi_field_calls: usize,

    // Track special case calls
    special_binary_calls: usize,
}

all_syntax_cases! {
    setup => {
        generated_fn_prefix: "comprehensive",
        additional_input_type: &mut Tracker
    }
    default_cases => {
        // 2-param handlers: work with Box, Vec, Punctuated smart unwrapping
        // AND with Option via system functions
        fn handle_expr(expr: &mut syn::Expr, tracker: &mut Tracker);
        fn handle_block(block: &mut syn::Block, tracker: &mut Tracker);
        fn handle_type(ty: &mut syn::Type, tracker: &mut Tracker);

        // 3+ param handler: works with Box, Vec, Punctuated
        // but NOT with Option fields (limitation)
        fn handle_multi_field(
            attrs: &mut Vec<syn::Attribute>,
            generics: &mut syn::Generics,
            tracker: &mut Tracker
        );
    }
    special_cases => {
        // Special case that intercepts binary expressions
        fn handle_binary_special(binary: &mut syn::ExprBinary, tracker: &mut Tracker);
    }
}

fn handle_expr(_expr: &mut syn::Expr, tracker: &mut Tracker) {
    tracker.expr_calls += 1;
}

fn handle_block(_block: &mut syn::Block, tracker: &mut Tracker) {
    tracker.block_calls += 1;
}

fn handle_type(_ty: &mut syn::Type, tracker: &mut Tracker) {
    tracker.type_calls += 1;
}

fn handle_multi_field(
    _attrs: &mut Vec<syn::Attribute>,
    _generics: &mut syn::Generics,
    tracker: &mut Tracker,
) {
    tracker.multi_field_calls += 1;
}

fn handle_binary_special(_binary: &mut syn::ExprBinary, tracker: &mut Tracker) {
    tracker.special_binary_calls += 1;
}

// ========== Box<T> Unwrapping Tests ==========

#[test]
fn box_unwrapping_2param_default() {
    let mut tracker = Tracker::default();

    // ExprUnary has Box<Expr> - should unwrap and call handle_expr
    let mut expr: syn::Expr = parse_quote! { !true };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Should call handle_expr for ExprUnary itself, then for inner Lit
    // Actual: 1 (just the outer ExprUnary - inner is handled but may be intercepted)
    assert!(
        tracker.expr_calls >= 1,
        "Should unwrap Box<Expr>, got {}",
        tracker.expr_calls
    );
}

#[test]
fn box_unwrapping_special_case() {
    let mut tracker = Tracker::default();

    // ExprBinary (special case) has Box<Expr> left and right
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Special handler should intercept
    assert_eq!(
        tracker.special_binary_calls, 1,
        "Special handler should be called"
    );
}

// ========== Vec<T> and Punctuated<T, _> Unwrapping Tests ==========

#[test]
fn vec_unwrapping_2param_default() {
    let mut tracker = Tracker::default();

    // ExprTuple has Punctuated<Expr, Token![,]> (behaves like Vec)
    let mut expr: syn::Expr = parse_quote! { (1, 2, 3) };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Should call handle_expr for outer tuple, then each element
    // Actual: calls for the 3 elements (tuple itself may not trigger handler)
    assert!(
        tracker.expr_calls >= 3,
        "Should iterate Vec/Punctuated and call handler per element, got {}",
        tracker.expr_calls
    );
}

#[test]
fn vec_unwrapping_3param_multifield() {
    let mut tracker = Tracker::default();

    // ItemStruct has both Vec<Attribute> and Generics
    let mut item: syn::Item = parse_quote! {
        #[derive(Debug)]
        #[allow(dead_code)]
        struct Foo<T> {
            field: T
        }
    };
    comprehensive_item_handle(&mut item, &mut tracker);

    // Multi-field handler should be called because both fields match
    assert!(
        tracker.multi_field_calls > 0,
        "Multi-field handler should match Vec<Attribute> + Generics"
    );
}

// ========== Option<T> Handling Tests ==========

#[test]
fn option_handling_2param_default() {
    let mut tracker = Tracker::default();

    // ExprIf has Option<Box<Expr>> in else clause
    let mut expr: syn::Expr = parse_quote! {
        if true { 1 } else { 2 }
    };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Should call handle_expr via system function option_box_expr
    // Outer if, then block expr (1), else block expr (2) = at least 3
    assert!(
        tracker.expr_calls >= 3,
        "Option<Box<Expr>> should be handled via system functions, got {}",
        tracker.expr_calls
    );
}

#[test]
fn option_handling_with_block() {
    let mut tracker = Tracker::default();

    // ItemFn has Option<Block> for body
    let mut item: syn::Item = parse_quote! {
        fn foo() {
            let x = 1;
            x + 2
        }
    };
    comprehensive_item_handle(&mut item, &mut tracker);

    // Should traverse into function body via Option<Block>
    assert!(
        tracker.block_calls >= 1,
        "Option<Block> should be handled, got {}",
        tracker.block_calls
    );
    assert!(
        tracker.expr_calls >= 2,
        "Expressions in block should be processed, got {}",
        tracker.expr_calls
    );
}

#[test]
fn option_handling_none_case() {
    let mut tracker = Tracker::default();

    // Trait method without body (Option<Block> is None)
    let mut item: syn::Item = parse_quote! {
        trait Foo {
            fn bar();
        }
    };
    comprehensive_item_handle(&mut item, &mut tracker);

    // Should not panic when Option is None
    // block_calls should be 0 since there's no body
}

// ========== Option<T> Limitation Tests (3+ params) ==========

#[test]
fn option_limitation_multifield_no_match() {
    let mut tracker = Tracker::default();

    // ExprForLoop has attrs: Vec<Attribute> and body: Block
    // But it does NOT have a Generics field
    // So multi_field_handler won't match (it needs both attrs AND generics)
    let mut expr: syn::Expr = parse_quote! {
        #[allow(unused)]
        for i in 0..10 {
            println!("{}", i);
        }
    };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // multi_field_handler requires BOTH attrs and generics
    // ExprForLoop doesn't have generics, so it won't match
    assert_eq!(
        tracker.multi_field_calls, 0,
        "Multi-field handler needs BOTH fields to match"
    );

    // But the block should still be processed
    assert!(
        tracker.block_calls >= 1,
        "Block should be processed via Option<Block>"
    );
}

// ========== Nested Unwrapping Tests ==========

#[test]
fn nested_box_unwrapping() {
    let mut tracker = Tracker::default();

    // Nested boxes: ExprUnary contains Box<Expr> which is ExprParen which contains Box<Expr>
    let mut expr: syn::Expr = parse_quote! { !(!(true)) };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Should unwrap through multiple layers
    assert!(
        tracker.expr_calls >= 4,
        "Should unwrap nested Box<Expr>, got {}",
        tracker.expr_calls
    );
}

#[test]
fn nested_vec_and_box() {
    let mut tracker = Tracker::default();

    // Vec of expressions, each containing Box
    let mut expr: syn::Expr = parse_quote! { (!1, !2, !3) };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Should iterate Vec and unwrap Box in each element
    // Each unary expr contains a Box<Expr> with a literal inside
    assert!(
        tracker.expr_calls >= 6,
        "Should iterate Vec and unwrap Box in each, got {}",
        tracker.expr_calls
    );
}

// ========== Type Unwrapping Tests ==========

#[test]
fn type_unwrapping_in_function() {
    let mut tracker = Tracker::default();

    // Function with return type and parameter types
    let mut item: syn::Item = parse_quote! {
        fn foo(a: i32, b: String) -> Result<Vec<u8>, Error> {
            Ok(vec![])
        }
    };
    comprehensive_item_handle(&mut item, &mut tracker);

    // Should process parameter types and return type
    assert!(
        tracker.type_calls >= 3,
        "Should process param and return types, got {}",
        tracker.type_calls
    );
}

// ========== Special Case Interception Test ==========

#[test]
fn special_case_stops_traversal() {
    let mut tracker = Tracker::default();

    // Binary expression with nested structure
    let mut expr: syn::Expr = parse_quote! { 1 + 2 };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Special handler intercepts, so child expressions (1, 2) won't be processed
    // by default handlers UNLESS special handler explicitly recurses
    assert_eq!(tracker.special_binary_calls, 1);

    // Since our special handler doesn't recurse, expr_calls should be minimal
    // (just the outer binary expr before special case intercepts)
}

#[test]
fn special_case_in_nested_context() {
    let mut tracker = Tracker::default();

    // Nested: tuple containing binary expressions
    let mut expr: syn::Expr = parse_quote! { (1 + 2, 3 * 4) };
    comprehensive_expr_handle(&mut expr, &mut tracker);

    // Special handler should be called for both binary operations
    assert_eq!(
        tracker.special_binary_calls, 2,
        "Should intercept both binary exprs"
    );
}

// ========== Complex Real-World Example ==========

#[test]
fn complex_struct_with_generics() {
    let mut tracker = Tracker::default();

    let mut item: syn::Item = parse_quote! {
        #[derive(Debug, Clone)]
        #[serde(rename_all = "camelCase")]
        pub struct Response<T, E>
        where
            T: Serialize,
            E: Error,
        {
            #[serde(skip)]
            data: Option<T>,
            error: Option<E>,
        }
    };
    comprehensive_item_handle(&mut item, &mut tracker);

    // Should call multi_field_handler (has attrs + generics)
    assert!(
        tracker.multi_field_calls > 0,
        "Should match struct with attrs and generics"
    );

    // Should process field types
    assert!(tracker.type_calls >= 2, "Should process field types");
}
